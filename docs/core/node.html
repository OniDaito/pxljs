<!DOCTYPE html>

<html>
<head>
  <title>node.coffee</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="../docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
    <ul class="sections">
        
          <li id="title">
              <div class="annotation">
                  <h1>node.coffee</h1>
              </div>
          </li>
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              <h2 id="about">ABOUT</h2>

            </div>
            
            <div class="content"><div class='highlight'><pre>             .__   
_________  __|  |  
\____ \  \/  /  |  
|  |_&gt; &gt;    &lt;|  |__
|   __<span class="hljs-regexp">/__/</span>\_ \____/
|__|        \/     js

                    PXL.js
                    Benjamin Blundell - ben@pxljs.com
                    http:<span class="hljs-regexp">//</span>pxljs.com

This software <span class="hljs-keyword">is</span> released under the MIT Licence. See LICENCE.txt <span class="hljs-keyword">for</span> details


Consists <span class="hljs-keyword">of</span> a matrix, a material, parent <span class="hljs-keyword">and</span> children <span class="hljs-keyword">for</span> the scene graph computation
Doesnt have to be drawn per-se</pre></div></div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <p>##</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
{Vec3, Vec4, Matrix3, Matrix4} = <span class="hljs-built_in">require</span> <span class="hljs-string">'../math/math'</span>
{matchWithShader} = <span class="hljs-built_in">require</span> <span class="hljs-string">'../gl/webgl'</span>
{Camera} = <span class="hljs-built_in">require</span> <span class="hljs-string">'../camera/camera'</span>
{Material} = <span class="hljs-built_in">require</span> <span class="hljs-string">'../material/material'</span>
{Texture} = <span class="hljs-built_in">require</span> <span class="hljs-string">'../gl/texture'</span>
{PointLight} = <span class="hljs-built_in">require</span> <span class="hljs-string">'../light/light'</span>
{Geometry} = <span class="hljs-built_in">require</span> <span class="hljs-string">'../geometry/primitive'</span>
{Contract} = <span class="hljs-built_in">require</span> <span class="hljs-string">'../gl/contract'</span>
{PXLWarningOnce} = <span class="hljs-built_in">require</span> <span class="hljs-string">'../util/log'</span>
uber = <span class="hljs-built_in">require</span> <span class="hljs-string">'../gl/uber_shader_paths'</span>

util = <span class="hljs-built_in">require</span> <span class="hljs-string">'../util/util'</span></pre></div></div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <p>##Node###
Arguably, the most important piece of code. The node represents the combination of all the
elements required for drawing. It has a matrix as the minimum, but can also accept materials
a piece of geometry, a shader and several textures and lights. It can have children but only
one parent. Nodes form the hierarchy/scene graph for PXL.
A node has a contract by default but this can be modifed or destroyed. A contract is between
the node and a shader that is currently bound
Reserved words, or rather, things that can be added to a node and have special meaning consist of</p>
<ul>
<li>geometry</li>
<li>material</li>
<li>shader</li>
<li>pointLight(s)</li>
<li>skeleton</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span></pre></div></div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <p>Dont have to pass any of these parameters but they will be inspected</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  constructor : <span class="hljs-function"><span class="hljs-params">(@geometry, @material, @shader)</span> -&gt;</span>

    @matrix =  <span class="hljs-keyword">new</span> Matrix4()          <span class="hljs-comment"># Local matrix for the user to mess with</span>
    @globalMatrix = <span class="hljs-keyword">new</span> Matrix4()     <span class="hljs-comment"># This is contracted to a shader (global basically)</span>
    @_normalMatrix = <span class="hljs-keyword">new</span> Matrix3()    <span class="hljs-comment"># Used for the normal matrix should we need it </span>
    @_mvpMatrix = <span class="hljs-keyword">new</span> Matrix4()       <span class="hljs-comment"># Combines with the camera to speed up certain operations</span>
    @children = []

    @contract = <span class="hljs-keyword">new</span> Contract()        <span class="hljs-comment"># Create a contract for this node with the basic contract items</span>
    
    @contract.roles.uModelMatrix      = <span class="hljs-string">"globalMatrix"</span>
    @contract.roles.uMVPMatrix        = <span class="hljs-string">"_mvpMatrix"</span>      <span class="hljs-comment"># precomputed model/view/perspective matrix</span>
    @contract.roles.uNormalMatrix     = <span class="hljs-string">"_normalMatrix"</span>
    @contract.roles.uUber0            = <span class="hljs-string">"_uber0"</span> <span class="hljs-comment"># The flag for the ubershader if we have one?</span>
    
    @_cached = <span class="hljs-literal">null</span>                   <span class="hljs-comment"># TODO A pointer to a cached version of this node. This is invalidated</span></pre></div></div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <p>if we add or remove nodes to this node or these above</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
    @pointLights = []</pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <p>TODO - At some point remove textures
if not @textures?
 @textures = []</p>

            </div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <p>add - Add things to this node, like geometry, materials or other nodes
TODO - we need a flag set here for _dirty and then run shader_automagic again</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  add : <span class="hljs-function"><span class="hljs-params">(p)</span> -&gt;</span>
    p._addToNode?(@)
    @</pre></div></div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <p>remove - remove a thing from this node</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  remove : <span class="hljs-function"><span class="hljs-params">(p)</span> -&gt;</span>
    p._removeFromNode?(@)
    @</pre></div></div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <p>private function to add nodes to nodes as children</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  _addToNode : <span class="hljs-function"><span class="hljs-params">(node)</span> -&gt;</span>
    node.children.push @
    @</pre></div></div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <p>return a copy of this node, referencing any geometry.
To duplicate geometry one needs to copy then add a fresh 
geometry with new to the new node.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  copy : <span class="hljs-function"><span class="hljs-params">()</span> -&gt;</span>
    util.clone @</pre></div></div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <p>Remove from the screen graph</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  del : <span class="hljs-function"><span class="hljs-params">(p)</span> -&gt;</span>
    <span class="hljs-keyword">if</span> p <span class="hljs-keyword">in</span> @children
      i = @children.indexOf(p) 
      @children.splice(i, <span class="hljs-number">1</span>)
    @</pre></div></div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <p>_removeFromNode - internal. Called when a node is removed from another node</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  _removeFromNode : <span class="hljs-function"><span class="hljs-params">(node)</span> -&gt;</span>
    node.del @
    @</pre></div></div>
            
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <p>draw - Draw the current node and all its children - a recursive call
TODO - we should cache the hierarchy, uniforms and textures separately
for speed. We shouldnt need to rebuild the hierarchy each time in the main
case so this would be a big saving.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
  draw : <span class="hljs-function"><span class="hljs-params">()</span> -&gt;</span></pre></div></div>
            
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <p>front is an object that represents the cumulated hierarchy at draw time</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    front =
      globalMatrix        : <span class="hljs-keyword">new</span> Matrix4()
      pointLights         : []
      _normalMatrix       : <span class="hljs-keyword">new</span> Matrix4()
      _mvpMatrix          : <span class="hljs-keyword">new</span> Matrix4()
      _uber0              : <span class="hljs-number">0</span>
      camera              : <span class="hljs-literal">undefined</span>
      shader              : <span class="hljs-literal">undefined</span>
      skeleton            : <span class="hljs-literal">undefined</span>

    @_draw(@, front )</pre></div></div>
            
        </li>
        
        
        <li id="section-15">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              <p>Recursive call to draw. Binds any textures on this node. Sets the lights
from the parent nodes, all the way down the tree. This node is then 
attempted to be brewed (if it has geometry) and if brewed, it is webgl drawn</p>

            </div>
            
        </li>
        
        
        <li id="section-16">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-16">&#182;</a>
              </div>
              <p>TODO - Eventually redo this function so we create a set of flat objects with 
a cache and all the required info.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
  _draw: <span class="hljs-function"><span class="hljs-params">(node, front)</span> -&gt;</span>
    
    front.globalMatrix = Matrix4.mult front.globalMatrix, node.matrix</pre></div></div>
            
        </li>
        
        
        <li id="section-17">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-17">&#182;</a>
              </div>
              <p>Setup the normal matrix</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    nm = node.globalMatrix.copy()</pre></div></div>
            
        </li>
        
        
        <li id="section-18">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-18">&#182;</a>
              </div>
              <p>Cameras are also passed down the tree but overidden if local
Also call update here</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">if</span> node.camera?
      front.camera = node.camera
      front.camera.update()
      front._uber0 = uber.uber_vertex_camera <span class="hljs-literal">true</span>, front._uber0
    
    <span class="hljs-keyword">if</span> front.camera?
      nm = Matrix4.mult(front.camera.m, nm)</pre></div></div>
            
        </li>
        
        
        <li id="section-19">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-19">&#182;</a>
              </div>
              <p>Create a precomputed model/view/perspective matrix for speed</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      front._mvpMatrix.copyFrom nm
      front._mvpMatrix.mult front.camera.m
      front._mvpMatrix.mult front.camera.p
    <span class="hljs-keyword">else</span>
      front._mvpMatrix.copyFrom nm</pre></div></div>
            
        </li>
        
        
        <li id="section-20">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-20">&#182;</a>
              </div>
              <p>TODO - Normal Matrix calculation better GPU or CPU side? 
TODO - We need to be careful about scaling here as well :S</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    front._normalMatrix = nm.getMatrix3().invert().transpose()

    <span class="hljs-keyword">for</span> light <span class="hljs-keyword">in</span> node.pointLights</pre></div></div>
            
        </li>
        
        
        <li id="section-21">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-21">&#182;</a>
              </div>
              <p>As Pointlight contains a static, global array for shader</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      light._preDraw()
      front.pointLights.push light

    <span class="hljs-keyword">if</span> node.pointLights.length &gt; <span class="hljs-number">0</span> 
      front._uber0 = uber.uber_lighting_point <span class="hljs-literal">true</span>, front._uber0</pre></div></div>
            
        </li>
        
        
        <li id="section-22">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-22">&#182;</a>
              </div>
              <p>Overwrite the ambient if there is one closer
TODO - combine perhaps?</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">if</span> node.ambientLight?
      front.ambientLight = node.ambientLight</pre></div></div>
            
        </li>
        
        
        <li id="section-23">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-23">&#182;</a>
              </div>
              <p>Shaders are passed down - if this node has no shader, one further up the
chain must already be bound but we bind late
TODO We should check if a user one is bound :S</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">if</span> node.shader?
      front.shader = node.shader</pre></div></div>
            
        </li>
        
        
        <li id="section-24">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-24">&#182;</a>
              </div>
              <p>TODO - Do we need all these if checks? Just copy null?</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
    <span class="hljs-keyword">if</span> node.geometry?
      <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node.geometry.brewed
        node.geometry.brew()
      front.geometry = node.geometry</pre></div></div>
            
        </li>
        
        
        <li id="section-25">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-25">&#182;</a>
              </div>
              <p>Pass down skeletons</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">if</span> node.skeleton?
      node.skeleton._preDraw()
      front.skeleton = node.skeleton
      front._uber0 = uber.uber_vertex_skinning <span class="hljs-literal">true</span>, front._uber0</pre></div></div>
            
        </li>
        
        
        <li id="section-26">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-26">&#182;</a>
              </div>
              <p>Material - Call predraw
Materials are inherited but can be overridden</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">if</span> node.material?
      node.material._preDraw()
      front.material = node.material
      front._uber0 = uber.uber_clear_material(front._uber0) | node.material._uber0</pre></div></div>
            
        </li>
        
        
        <li id="section-27">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-27">&#182;</a>
              </div>
              <p>Copy any user contract items (added to the contract) that have not already been added
as users can add data to be passed in the contract (like uColour).
Do this by reference for now.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">for</span> key <span class="hljs-keyword">of</span> @contract.roles
      <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> front[key]?
        front[key] = node[key]</pre></div></div>
            
        </li>
        
        
        <li id="section-28">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-28">&#182;</a>
              </div>
              <p>Reference the current node contract.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    front.contract = node.contract</pre></div></div>
            
        </li>
        
        
        <li id="section-29">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-29">&#182;</a>
              </div>
              <p>Actually make the binds with WebGL here.
Perhaps better move back to WebGL file?</p>

            </div>
            
        </li>
        
        
        <li id="section-30">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-30">&#182;</a>
              </div>
              <p>Only draw if we have the context (think tests and the like)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">if</span> PXL.Context.gl?

      gl = PXL.Context.gl</pre></div></div>
            
        </li>
        
        
        <li id="section-31">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-31">&#182;</a>
              </div>
              <p>Actual Draw
Put a line in here to check we also have a shader on the context</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> front.geometry? <span class="hljs-keyword">and</span> front.shader?
        PXL.Context.shader = front.shader
        PXL.Context.shader.bind()

        matchWithShader front</pre></div></div>
            
        </li>
        
        
        <li id="section-32">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-32">&#182;</a>
              </div>
              <p>Quick check for unbound uniforms</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> PXL.Context.debug
          <span class="hljs-keyword">for</span> u <span class="hljs-keyword">in</span> PXL.Context.shader.contract.findUnmatched()
            PXLWarningOnce(<span class="hljs-string">"Unmatched uniform/attribute in shader: "</span> + u.name)
                 
        front.geometry.drawGL()</pre></div></div>
            
        </li>
        
        
        <li id="section-33">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-33">&#182;</a>
              </div>
              <p>unbind</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        PXL.Context.shader.unbind()
        PXL.Context.shader = <span class="hljs-literal">undefined</span>

    <span class="hljs-keyword">for</span> child <span class="hljs-keyword">in</span> node.children</pre></div></div>
            
        </li>
        
        
        <li id="section-34">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-34">&#182;</a>
              </div>
              <p>We need to clone front so we dont change it permanently
Seems the fastest way is to just copy - json stringify then parse appears not to work</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      front_child = 
        globalMatrix        : front.globalMatrix.copy()
        pointLights         : front.pointLights.slice(<span class="hljs-number">0</span>)
        _normalMatrix       : front._normalMatrix.copy()
        _mvpMatrix          : front._mvpMatrix.copy()
        _uber0              : front._uber0
        camera              : front.camera
        shader              : front.shader
        material            : front.material
        contract            : front.contract
        skeleton            : front.skeleton

      @_draw(child, front_child)</pre></div></div>
            
        </li>
        
        
        <li id="section-35">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-35">&#182;</a>
              </div>
              <p>TODO Pre and post draws should probably be in a class or similar? I.e check all members of the 
front and see if they have a pre and post</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">if</span> front.material?
      front.material._postDraw()

    <span class="hljs-keyword">if</span> front.skeleton?
      front.skeleton._postDraw()

    node

<span class="hljs-built_in">module</span>.exports = 
  Node : Node</pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
