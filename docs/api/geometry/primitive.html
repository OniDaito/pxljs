<!DOCTYPE html><html lang="en"><head><title>geometry/primitive</title></head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0"><meta name="groc-relative-root" content="../"><meta name="groc-document-path" content="geometry/primitive"><meta name="groc-project-path" content="src/geometry/primitive.coffee"><link rel="stylesheet" type="text/css" media="all" href="../assets/style.css"><script type="text/javascript" src="../assets/behavior.js"></script><body><div id="meta"><div class="file-path">src/geometry/primitive.coffee</div></div><div id="document"><div class="segment"><div class="comments "><div class="wrapper"><pre><code>             .__   
_________  __|  |  
\____ \  \/  /  |  
|  |_&gt; &gt;    &lt;|  |__
|   __/__/\_ \____/
|__|        \/     js

                PXL.js
                Benjamin Blundell - ben@pxljs.com
                http://pxljs.com

This software is released under the MIT Licence. See LICENCE.txt for details</code></pre>
<p>Primitive Objects - holds support for the various buffers we need</p>
<ul>
<li>TODO</li>
<li>Should we use mixins or similar for adding texture co-ords and colours?</li>
<li>There is probably a much better methodology here I think</li>
<li>draw should be implicit when a primitive is created / added methinx - but what of order? Placement? Z Depth?</li>
</ul>
<p>Three uses a dynamic flag. potential there.
Need to bind functions so that if vertices are updated, we change the buffers! Should be possible
Also, we are assuming floats here too! Normally thats the case but not always I suspect!
Also GL_TRIANGLES as well (but thats probably for the best)
Context is taken from the actual context set in the object but what if we wish to change context?
When applying materials, we may need to AUTOGEN stuff - thats not a bad idea actually</p></div></div><div class="code"><div class="wrapper">{RGBA,RGB} = <span class="hljs-built_in">require</span> <span class="hljs-string">'../colour/colour'</span>
{Matrix4,Vec2,Vec3,Vec4} = <span class="hljs-built_in">require</span> <span class="hljs-string">'../math/math'</span>
{Contract} = <span class="hljs-built_in">require</span> <span class="hljs-string">'../gl/contract'</span>
{GeometryBrewer} = <span class="hljs-built_in">require</span> <span class="hljs-string">'../gl/webgl'</span>
{PXLWarning, PXLError, PXLLog} = <span class="hljs-built_in">require</span> <span class="hljs-string">'../util/log'</span>

util = <span class="hljs-built_in">require</span> <span class="hljs-string">'../util/util'</span></div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p><span class='doc-section-header'> vertices - vertices - actual vertices if any. If this geometry is flat we use vertex components</p>
<ul>
<li>i.e @p for position, @t for texcoords etc and layout - gl constant to say how this should be treated (lines etc)</span></li>
</ul>
<h2 id="geometry">Geometry</h2>
<p>Represents actually geometry - a collection of vertices that can be drawn, with some
organisation
Geometry is either a set of vertices ready to be flattened into arrays to go onto the
GPU or there is a set of existing Float32Arrays with the data
The latter is called @flat
Context must already be enabled as we are using gl constants (good idea?)</p></div></div><div class="code"><div class="wrapper"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Geometry</span></span>
  </div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p><strong>@constructor</strong></p></div></div><div class="code"><div class="wrapper">  constructor : <span class="hljs-function"><span class="hljs-params">()</span> -&gt;</span>
    <span class="hljs-property">@vertices</span> = []
    </div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>By using a context here, we do end up needing a context at this point
we arent really decoupled with our geometry - tough choice really
TODO - Could just use the numbers? - I think we will :D</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-property">@layout</span> = GL.TRIANGLES <span class="hljs-keyword">if</span> GL?
    <span class="hljs-property">@flat</span> = <span class="hljs-literal">false</span> <span class="hljs-comment"># A Hint that suggests the data is already held in flat, Float32Arrays</span>
    <span class="hljs-property">@_flat_sizes</span> = {} <span class="hljs-comment"># Record the sizes if using a flat structure</span>
    <span class="hljs-property">@faces</span> = []
    <span class="hljs-property">@indexed</span> = <span class="hljs-literal">false</span>
    <span class="hljs-property">@indices</span> = []
    <span class="hljs-property">@contract</span> = <span class="hljs-keyword">new</span> Contract()</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>The default roles
TODO - Contract should probably be split into user and default with default being
static - Can probably do that in the contract class
atm we only check for the named variable &#39;contract&#39; - perhaps there is a better way?</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-property">@contract</span>.roles.aVertexPosition   = <span class="hljs-string">"vertexpBuffer"</span>
    <span class="hljs-property">@contract</span>.roles.aVertexTexCoord   = <span class="hljs-string">"vertextBuffer"</span>
    <span class="hljs-property">@contract</span>.roles.aVertexNormal     = <span class="hljs-string">"vertexnBuffer"</span>
    <span class="hljs-property">@contract</span>.roles.aVertexColour     = <span class="hljs-string">"vertexcBuffer"</span>
    <span class="hljs-property">@contract</span>.roles.aVertexTangent    = <span class="hljs-string">"vertexaBuffer"</span>
    <span class="hljs-property">@contract</span>.roles.aVertexBarycentre = <span class="hljs-string">"vertexyBuffer"</span>
    <span class="hljs-property">@contract</span>.roles.aVertexSkinWeight = <span class="hljs-string">"vertexwBuffer"</span>
    <span class="hljs-property">@contract</span>.roles.aVertexBoneIndex  = <span class="hljs-string">"vertexiBuffer"</span>

    util.extend(@, GeometryBrewer)
    <span class="hljs-property">@brewed</span> = <span class="hljs-literal">false</span>

  _addToNode : <span class="hljs-function"><span class="hljs-params">(node)</span> -&gt;</span>
    node.geometry = @
    @</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p><strong>flatten</strong> </p>
<ul>
<li>reutns a list of Number - [v0.x, v0.y, v0.z, (v0.w), (v0.r, v0.g, v0.b) ...]</li>
</ul></div></div><div class="code"><div class="wrapper">  flatten :<span class="hljs-function"><span class="hljs-params">()</span> -&gt;</span>
    t = []
    <span class="hljs-keyword">for</span> vertex <span class="hljs-keyword">in</span> <span class="hljs-property">@vertices</span>
      t.concat vertex.flatten()
    t</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p><strong>setIndex</strong> - if there are indicies in this geometry, set one here</p>
<ul>
<li><strong>idx</strong> - a Number - Integer - Required</li>
<li><strong>value</strong> - a Number- Integer - Required</li>
<li>returns this</li>
</ul></div></div><div class="code"><div class="wrapper">  setIndex : <span class="hljs-function"><span class="hljs-params">(idx, value)</span> -&gt;</span>
    <span class="hljs-property">@indices</span>[idx] = value
    @</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p><strong>setVertex</strong></p>
<ul>
<li><strong>idx</strong> - a Number - Integer - Required</li>
<li><strong>vertex</strong> - a Vertex - Required</li>
<li>returns this</li>
</ul></div></div><div class="code"><div class="wrapper">  setVertex : <span class="hljs-function"><span class="hljs-params">(idx, vertex)</span> -&gt;</span>
    <span class="hljs-property">@vertices</span>[idx] = vertex
    @</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p><strong>addVertex</strong> </p>
<ul>
<li><strong>v</strong> - a Vertex - Required</li>
<li>return this</li>
</ul></div></div><div class="code"><div class="wrapper">  addVertex : <span class="hljs-function"><span class="hljs-params">(v)</span> -&gt;</span>
    <span class="hljs-property">@vertices</span>.push v
    @</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p><strong>addIndex</strong></p>
<ul>
<li><strong>idx</strong> -  a Number - Integer - Required</li>
</ul></div></div><div class="code"><div class="wrapper">  addIndex : <span class="hljs-function"><span class="hljs-params">(idx)</span> -&gt;</span>
    <span class="hljs-property">@indices</span>.push idx</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p><strong>getTrisIndexer</strong> - returns a function that allows us to iterate over the triangles
We look at the instanceof for the organisation of the triangles
TODO - Non indexed TRIANGLE_STRIPs need to be sorted</p>
<ul>
<li>returns a function with the following parameters
-- <strong>index</strong> - a Number - Integer - Required
-- returns an Array of Vec3 or an Array of Vertex (depending if the geometry is flat)</li>
</ul></div></div><div class="code"><div class="wrapper">  getTrisIndexer : <span class="hljs-function"><span class="hljs-params">()</span> -&gt;</span>
<span class="hljs-function">  
    <span class="hljs-title">flat_indexed_tris</span> = <span class="hljs-params">(index)</span> =&gt;</span>
      <span class="hljs-keyword">return</span> [ <span class="hljs-keyword">new</span> Vec3( <span class="hljs-property">@p</span>[ <span class="hljs-property">@indices</span>[index * <span class="hljs-number">3</span>] * <span class="hljs-number">3</span> ], <span class="hljs-property">@p</span>[ <span class="hljs-property">@indices</span>[index * <span class="hljs-number">3</span>] * <span class="hljs-number">3</span> + <span class="hljs-number">1</span> ], <span class="hljs-property">@p</span>[ <span class="hljs-property">@indices</span>[index * <span class="hljs-number">3</span>] * <span class="hljs-number">3</span> + <span class="hljs-number">2</span>]),
        <span class="hljs-keyword">new</span> Vec3( <span class="hljs-property">@p</span>[ <span class="hljs-property">@indices</span>[index * <span class="hljs-number">3</span> + <span class="hljs-number">1</span>] * <span class="hljs-number">3</span>], <span class="hljs-property">@p</span>[ <span class="hljs-property">@indices</span>[index * <span class="hljs-number">3</span> + <span class="hljs-number">1</span>] * <span class="hljs-number">3</span> + <span class="hljs-number">1</span>], <span class="hljs-property">@p</span>[ <span class="hljs-property">@indices</span>[index * <span class="hljs-number">3</span> + <span class="hljs-number">1</span>] * <span class="hljs-number">3</span> + <span class="hljs-number">2</span>]),
        <span class="hljs-keyword">new</span> Vec3( <span class="hljs-property">@p</span>[ <span class="hljs-property">@indices</span>[index * <span class="hljs-number">3</span> + <span class="hljs-number">2</span>] * <span class="hljs-number">3</span>], <span class="hljs-property">@p</span>[ <span class="hljs-property">@indices</span>[index * <span class="hljs-number">3</span> + <span class="hljs-number">2</span>] * <span class="hljs-number">3</span> + <span class="hljs-number">1</span>], <span class="hljs-property">@p</span>[ <span class="hljs-property">@indices</span>[index * <span class="hljs-number">3</span> + <span class="hljs-number">2</span>] * <span class="hljs-number">3</span> + <span class="hljs-number">2</span>])]
<span class="hljs-function">  

    <span class="hljs-title">flat_non_indexed_tris</span> = <span class="hljs-params">(index)</span> =&gt;</span>
      <span class="hljs-keyword">return</span> [ <span class="hljs-keyword">new</span> Vec3( <span class="hljs-property">@p</span>[ index * <span class="hljs-number">9</span>], <span class="hljs-property">@p</span>[ index * <span class="hljs-number">9</span> + <span class="hljs-number">1</span>], <span class="hljs-property">@p</span>[ index * <span class="hljs-number">9</span> + <span class="hljs-number">2</span>]),
        <span class="hljs-keyword">new</span> Vec3( <span class="hljs-property">@p</span>[ index * <span class="hljs-number">9</span> + <span class="hljs-number">3</span>], <span class="hljs-property">@p</span>[ index * <span class="hljs-number">9</span> + <span class="hljs-number">4</span>], <span class="hljs-property">@p</span>[ index * <span class="hljs-number">9</span> + <span class="hljs-number">5</span>]),
        <span class="hljs-keyword">new</span> Vec3( <span class="hljs-property">@p</span>[ index * <span class="hljs-number">9</span> + <span class="hljs-number">6</span>], <span class="hljs-property">@p</span>[ index * <span class="hljs-number">9</span> + <span class="hljs-number">7</span>], <span class="hljs-property">@p</span>[ index * <span class="hljs-number">9</span> + <span class="hljs-number">8</span>])]
<span class="hljs-function">
    <span class="hljs-title">pointy_indexed_tris</span> = <span class="hljs-params">(index)</span> =&gt;</span>
      <span class="hljs-keyword">return</span> [<span class="hljs-property">@vertices</span>[ <span class="hljs-property">@indices</span>[index * <span class="hljs-number">3</span>]], <span class="hljs-property">@vertices</span>[ <span class="hljs-property">@indices</span>[index * <span class="hljs-number">3</span> + <span class="hljs-number">1</span>]], <span class="hljs-property">@vertices</span>[ <span class="hljs-property">@indices</span>[index * <span class="hljs-number">3</span> + <span class="hljs-number">2</span>]]]
<span class="hljs-function">
    <span class="hljs-title">point_non_indexed_tris</span> = <span class="hljs-params">(index)</span> =&gt;</span>
      <span class="hljs-keyword">return</span> [<span class="hljs-property">@vertices</span>[ index * <span class="hljs-number">3</span>], <span class="hljs-property">@vertices</span>[ index * <span class="hljs-number">3</span> + <span class="hljs-number">1</span>], <span class="hljs-property">@vertices</span>[ index * <span class="hljs-number">3</span> + <span class="hljs-number">2</span>]]

    <span class="hljs-keyword">if</span> <span class="hljs-property">@flat</span>
      <span class="hljs-keyword">if</span> <span class="hljs-property">@indexed</span>
        <span class="hljs-keyword">return</span> flat_indexed_tris
      <span class="hljs-keyword">else</span>
        <span class="hljs-keyword">return</span> flat_non_indexed_tris
    <span class="hljs-keyword">else</span>
      <span class="hljs-keyword">if</span> <span class="hljs-property">@indexed</span>
        <span class="hljs-keyword">return</span> pointy_indexed_tris
      <span class="hljs-keyword">else</span>
        <span class="hljs-keyword">return</span> point_non_indexed_tris</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p><strong>getNumTris</strong> - Return the number of triangles in this geometry
returns a Number</p></div></div><div class="code"><div class="wrapper">  getNumTris : <span class="hljs-function"><span class="hljs-params">()</span> -&gt;</span>
    <span class="hljs-keyword">if</span> @ <span class="hljs-keyword">instanceof</span> PlaneFlat
      <span class="hljs-keyword">return</span> <span class="hljs-property">@indices</span>.length - <span class="hljs-number">2</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>GL_TRIANGLES Based things</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">if</span> <span class="hljs-property">@flat</span>
      <span class="hljs-keyword">if</span> <span class="hljs-property">@indexed</span>
        <span class="hljs-keyword">return</span> <span class="hljs-property">@indices</span>.length / <span class="hljs-number">3</span>
      <span class="hljs-keyword">else</span>
        <span class="hljs-keyword">return</span> <span class="hljs-property">@p</span>.length / <span class="hljs-number">3</span>

    <span class="hljs-keyword">else</span>
      <span class="hljs-keyword">if</span> <span class="hljs-property">@indexed</span>
        <span class="hljs-keyword">return</span> <span class="hljs-property">@indices</span>.length / <span class="hljs-number">3</span>
      <span class="hljs-keyword">else</span>
        <span class="hljs-keyword">return</span> <span class="hljs-property">@vertices</span>.length / <span class="hljs-number">3</span></div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p><span class='doc-section-header'> p - position - a Vec3, c - colour - a Colour (usually RGBA), n - normals - a Vec3, t - textures (u,v) - a Vec2, a - tangent - a Vec3, y - barycentre, w - skinweight, and i - boneindex
It is possible to pass in more arguments. Any object held on the vertex will be converted
to a buffer of the same name + &quot;&quot;</span></p>
<h2 id="vertex">Vertex</h2>
<p>Lowest class. We use this because we need to do things on a vertex basis when we brew
We need position as a minimum. Optional Colour, Normal and texture and tangent
vertices essentially copy by reference unless a Vec or similar is not copied. This is
the general practice of PXL - inkeeping with javascript
The defaults are</p></div></div><div class="code"><div class="wrapper"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Vertex</span></span>
  </div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p><strong>@constructor</strong></p>
<ul>
<li><strong>named_arguments</strong> - an Object with named arguments
You can pass in whatever named arguments you want. They will be attached to the 
Vertex object. Some of these have default names, such as p for position and 
c for colour. So pass in { &#39;p&#39; :  Vec3(1,1,1) } for example</li>
</ul></div></div><div class="code"><div class="wrapper">  <span class="hljs-attribute">constructor</span>: <span class="hljs-function"><span class="hljs-params">(named_arguments)</span> -&gt;</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Copy the bits over</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">for</span> key <span class="hljs-keyword">of</span> named_arguments
      @[key] = named_arguments[key]</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>TODO - We should check the types being passed in, particularly if we are in debug mode</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-property">@p</span>?
      <span class="hljs-property">@p</span> = <span class="hljs-keyword">new</span> Vec3 <span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>
    <span class="hljs-keyword">else</span>
      <span class="hljs-keyword">if</span> <span class="hljs-property">@p</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">instanceof</span> Vec3
        PXLWarning(<span class="hljs-string">"Passing position data to Vertex that is not Vec3"</span>)        </div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p><strong>flatten</strong> - take all the named attributes and call flatten on them</p>
<ul>
<li>returns an Array</li>
</ul></div></div><div class="code"><div class="wrapper">  <span class="hljs-attribute">flatten</span>: <span class="hljs-function"><span class="hljs-params">()</span> -&gt;</span>
    t = []</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Flatten all keys</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">for</span> key <span class="hljs-keyword">of</span> @
      t.concat @[key].flatten()

    t</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h2 id="triangle">Triangle</h2>
<p>A triangle. This CAN be extended to be drawn on its own but doesnt have to be
TODO - is a Triangle really geometry? It is kinda but since we have loads of triangles
in things like a mesh shouldnt we really not do that? :S</p></div></div><div class="code"><div class="wrapper"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Triangle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Geometry</span></span>
  </div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p><strong>@constructor</strong></p>
<ul>
<li><strong>p0</strong> - a Vertex - Default v.p (-1,-1,0)</li>
<li><strong>p1</strong> - a Vertex - Default v.p (1,-1,0)</li>
<li><strong>p2</strong> - a Vertex - Default v.p (0,1,0)</li>
<li><strong>n</strong> - a Vec3 - normalised</li>
</ul></div></div><div class="code"><div class="wrapper">  
  <span class="hljs-attribute">constructor</span>: <span class="hljs-function"><span class="hljs-params">(p0,p1,p2,<span class="hljs-property">@n</span>)</span> -&gt;</span>
    <span class="hljs-keyword">super</span>()</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>we dont have 3 vectors, create a unit triangle with -1 to 1 with anticlockwise winding</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> p0? <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> p1? <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> p2?
      <span class="hljs-property">@vertices</span> = [ 
        <span class="hljs-keyword">new</span> Vertex
          p : <span class="hljs-keyword">new</span> Vec3 -<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>,<span class="hljs-number">0</span> 
        <span class="hljs-keyword">new</span> Vertex
          p : <span class="hljs-keyword">new</span> Vec3 <span class="hljs-number">1</span>,-<span class="hljs-number">1</span>,<span class="hljs-number">0</span> 
        <span class="hljs-keyword">new</span> Vertex
          p : <span class="hljs-keyword">new</span> Vec3 <span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>
      ]
    <span class="hljs-keyword">else</span>
      <span class="hljs-property">@vertices</span> = [p0,p1,p2]

    <span class="hljs-property">@computeFaceNormal</span>() <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-property">@n</span>?</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p><strong>flatten</strong> - squash the vertices into an array</p>
<ul>
<li>returns an Array</li>
</ul></div></div><div class="code"><div class="wrapper">  <span class="hljs-attribute">flatten</span>: <span class="hljs-function"><span class="hljs-params">()</span> -&gt;</span>
    t = []
    t = t.concat <span class="hljs-property">@vertices</span>[<span class="hljs-number">0</span>].flatten()
    t = t.concat <span class="hljs-property">@vertices</span>[<span class="hljs-number">1</span>].flatten()
    t = t.concat <span class="hljs-property">@vertices</span>[<span class="hljs-number">2</span>].flatten()
    t
  </div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p><strong>computeFaceNormal</strong> - sets the internal normal based on the points of the triangle</p>
<ul>
<li>returns this</li>
</ul></div></div><div class="code"><div class="wrapper">  <span class="hljs-attribute">computeFaceNormal</span>: <span class="hljs-function"><span class="hljs-params">()</span>-&gt;</span>
    l0 = Vec3.sub(<span class="hljs-property">@vertices</span>[<span class="hljs-number">1</span>].p, <span class="hljs-property">@vertices</span>[<span class="hljs-number">0</span>].p)
    l1 = Vec3.sub(<span class="hljs-property">@vertices</span>[<span class="hljs-number">2</span>].p, <span class="hljs-property">@vertices</span>[<span class="hljs-number">1</span>].p)
    <span class="hljs-property">@n</span> = l0.cross(l1)
    <span class="hljs-property">@n</span>.normalize()
    
    @</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h2 id="quad">Quad</h2>
<p>Our basic Quad, drawn as a tristrip. Assume planar triangles</p></div></div><div class="code"><div class="wrapper"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Quad</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Geometry</span></span>
  </div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p><strong>@constructor</strong></p>
<ul>
<li><strong>p0</strong> - a Vertex - Default v.p(-1,1,0), v.c(1,1,1,1), v.n(0,0,1), v.t(0,1) </li>
<li><strong>p1</strong> - a Vertex - Default v.p(-1,-1,0), v.c(1,1,1,1), v.n(0,0,1), v.t(0,0)</li>
<li><strong>p2</strong> - a Vertex - Default v.p(1,1,0), v.c(1,1,1,1), v.n(0,0,1), v.t(1,1)</li>
<li><strong>p3</strong> - a Vertex - Default v.p(1,-1,0), v.c(1,1,1,1), v.n(0,0,1), v.t(1,0)</li>
<li><strong>n</strong> - a Vec3 - normalised - Default Vec3(0,0,1)</li>
</ul></div></div><div class="code"><div class="wrapper"> 
  <span class="hljs-attribute">constructor</span>: <span class="hljs-function"><span class="hljs-params">(p0,p1,p2,p3,<span class="hljs-property">@n</span>)</span> -&gt;</span>
    <span class="hljs-keyword">super</span>()</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>we dont have 4 vectors, create a 2 wide quad with -1 to 1 with anticlockwise winding</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> p0? <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> p1? <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> p2? <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> p3?
      p0 = <span class="hljs-keyword">new</span> Vertex
        p : <span class="hljs-keyword">new</span> Vec3 -<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span> 
        c : <span class="hljs-keyword">new</span> RGBA <span class="hljs-number">1.0</span>,<span class="hljs-number">1.0</span>,<span class="hljs-number">1.0</span>,<span class="hljs-number">1.0</span>
        n : <span class="hljs-keyword">new</span> Vec3 <span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>
        t : <span class="hljs-keyword">new</span> Vec2 <span class="hljs-number">0</span>,<span class="hljs-number">1</span>

      p1 = <span class="hljs-keyword">new</span> Vertex 
        p : <span class="hljs-keyword">new</span> Vec3 -<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>
        c : <span class="hljs-keyword">new</span> RGBA <span class="hljs-number">1.0</span>,<span class="hljs-number">1.0</span>,<span class="hljs-number">1.0</span>,<span class="hljs-number">1.0</span>
        n : <span class="hljs-keyword">new</span> Vec3 <span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>
        t : <span class="hljs-keyword">new</span> Vec2 <span class="hljs-number">0</span>,<span class="hljs-number">0</span>
      
      p2 = <span class="hljs-keyword">new</span> Vertex
        p : <span class="hljs-keyword">new</span> Vec3 <span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>
        c : <span class="hljs-keyword">new</span> RGBA <span class="hljs-number">1.0</span>,<span class="hljs-number">1.0</span>,<span class="hljs-number">1.0</span>,<span class="hljs-number">1.0</span>
        n : <span class="hljs-keyword">new</span> Vec3 <span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>
        t : <span class="hljs-keyword">new</span> Vec2 <span class="hljs-number">1</span>,<span class="hljs-number">1</span>
      
      p3 = <span class="hljs-keyword">new</span> Vertex
        p : <span class="hljs-keyword">new</span> Vec3 <span class="hljs-number">1</span>,-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>
        c : <span class="hljs-keyword">new</span> RGBA <span class="hljs-number">1.0</span>,<span class="hljs-number">1.0</span>,<span class="hljs-number">1.0</span>,<span class="hljs-number">1.0</span>
        n : <span class="hljs-keyword">new</span> Vec3 <span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>
        t : <span class="hljs-keyword">new</span> Vec2 <span class="hljs-number">1</span>,<span class="hljs-number">0</span>

    <span class="hljs-property">@vertices</span> = [p0,p1,p2,p3]
    gl = GL
    <span class="hljs-property">@layout</span> = GL.TRIANGLE_STRIP <span class="hljs-keyword">if</span> GL?

    <span class="hljs-property">@computeFaceNormal</span>() <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-property">@n</span>?
 </div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p><strong>computeFaceNormal</strong> - sets the internal normal based on the points of the triangle</p>
<ul>
<li>returns this</li>
</ul></div></div><div class="code"><div class="wrapper">  <span class="hljs-attribute">computeFaceNormal</span>: <span class="hljs-function"><span class="hljs-params">()</span>-&gt;</span>
    l0 = Vec3.sub(<span class="hljs-property">@vertices</span>[<span class="hljs-number">1</span>].p, <span class="hljs-property">@vertices</span>[<span class="hljs-number">0</span>].p)
    l1 = Vec3.sub(<span class="hljs-property">@vertices</span>[<span class="hljs-number">2</span>].p, <span class="hljs-property">@vertices</span>[<span class="hljs-number">1</span>].p)
    <span class="hljs-property">@n</span> = l0.cross(l1)
    <span class="hljs-property">@n</span>.normalize()
   
    @</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p><strong>flatten</strong> - squash the vertices into an array</p>
<ul>
<li>returns an Array</li>
</ul></div></div><div class="code"><div class="wrapper">  <span class="hljs-attribute">flatten</span>: <span class="hljs-function"><span class="hljs-params">()</span> -&gt;</span>
    t = []
    t = t.concat <span class="hljs-property">@vertices</span>[<span class="hljs-number">0</span>].flatten()
    t = t.concat <span class="hljs-property">@vertices</span>[<span class="hljs-number">1</span>].flatten()
    t = t.concat <span class="hljs-property">@vertices</span>[<span class="hljs-number">2</span>].flatten()
    t = t.concat <span class="hljs-property">@vertices</span>[<span class="hljs-number">3</span>].flatten()
    t</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h2 id="vertexsoup">VertexSoup</h2>
<p>A Place holder class for a collection of non indexed vertices, likely to be drawn out as lines
or some arbitrary polygon
vertex_list - the list of vertices to make this from</p></div></div><div class="code"><div class="wrapper"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VertexSoup</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Geometry</span> </span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p><strong> constructor </strong></p>
<ul>
<li><strong>vertex_list</strong> - an Array of Vertex</li>
</ul></div></div><div class="code"><div class="wrapper">  <span class="hljs-attribute">constructor</span>: <span class="hljs-function"><span class="hljs-params">(vertex_list)</span> -&gt;</span>
    <span class="hljs-keyword">super</span>()
    gl = GL
    <span class="hljs-property">@layout</span> = GL.POINTS <span class="hljs-keyword">if</span> GL?

    <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> vertex_list
      <span class="hljs-property">@vertices</span>.push v</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h2 id="trianglemesh">TriangleMesh</h2>
<p>A mesh made up of triangles that have the same kinds of vertices
Can be created in several ways but the outcome is a set of indexed
or non indexed buffers
By adding triangles / quads we copy the vertex data semantically 
but dont actually keep the underlying primitives save for the vertices
We can infer the triangles back from this however should we wish</p></div></div><div class="code"><div class="wrapper"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TriangleMesh</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Geometry</span></span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>TODO - allow indexing but also allowing passing in indices as well - speeds things 
up with the json model</p></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p><strong>@constructor</strong> </p>
<ul>
<li><strong>indexed</strong> - a Boolean - Required</li>
</ul></div></div><div class="code"><div class="wrapper">  constructor : <span class="hljs-function"><span class="hljs-params">(indexed)</span> -&gt;</span>
    <span class="hljs-keyword">super</span>()
    <span class="hljs-property">@vertices</span> = []
    <span class="hljs-property">@faces</span> = []
    <span class="hljs-property">@indexed</span> = indexed

    <span class="hljs-property">@layout</span> = GL.TRIANGLES <span class="hljs-keyword">if</span> GL?</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p><strong>addTriangle</strong> - Add a triangle to this mesh checking for any problems with vertex duplication</p>
<ul>
<li><strong>t</strong> - a Triangle</li>
<li>returns this</li>
</ul></div></div><div class="code"><div class="wrapper">  addTriangle : <span class="hljs-function"><span class="hljs-params">(t)</span> -&gt;</span>
    <span class="hljs-keyword">if</span> <span class="hljs-property">@indexed</span>
      <span class="hljs-keyword">for</span> idx <span class="hljs-keyword">in</span> [<span class="hljs-number">0.</span><span class="hljs-number">.2</span>]
        p = <span class="hljs-property">@_findV</span>(t.vertices[idx]) 
        <span class="hljs-keyword">if</span> p == -<span class="hljs-number">1</span>
          <span class="hljs-property">@vertices</span>.push t.vertices[idx]
          ti = <span class="hljs-property">@vertices</span>.length
          ti -= <span class="hljs-number">1</span>
          t.vertices[idx]._idx = ti
          <span class="hljs-property">@indices</span>.push ti

        <span class="hljs-keyword">else</span>
          <span class="hljs-property">@indices</span>.push(p)

    <span class="hljs-keyword">else</span>
      <span class="hljs-property">@vertices</span>.push v <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> t.v

    <span class="hljs-property">@faces</span>.push(t)
    @</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p><strong>addTriangleFromIndices </strong> If we&#39;ve added indicies by hand, we can create triangles from these
indices. Used in the MD5Model class</p>
<ul>
<li><strong>indices</strong> - an Array of Integer - Required</li>
<li>returns this</li>
</ul></div></div><div class="code"><div class="wrapper">  addTriangleFromIndices : <span class="hljs-function"><span class="hljs-params">(indices)</span> -&gt;</span>
    <span class="hljs-keyword">if</span> <span class="hljs-property">@indexed</span>
      points = []
      <span class="hljs-keyword">for</span> idx <span class="hljs-keyword">in</span> indices
        <span class="hljs-keyword">if</span> idx &gt; -<span class="hljs-number">1</span> <span class="hljs-keyword">and</span> idx &lt; <span class="hljs-property">@indices</span>.length
          points.push <span class="hljs-property">@vertices</span>[idx]
        <span class="hljs-keyword">else</span> 
          PXLError <span class="hljs-string">"Attempting to create a triangle from indicies that dont exist"</span>

      t = <span class="hljs-keyword">new</span> Triangle <span class="hljs-property">@vertices</span>[points[<span class="hljs-number">0</span>]], <span class="hljs-property">@vertices</span>[points[<span class="hljs-number">1</span>]], <span class="hljs-property">@vertices</span>[points[<span class="hljs-number">2</span>]]
      <span class="hljs-property">@faces</span>.push t

    @</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p><strong>addQuad</strong> - Add a quad, breaking it down into its component parts</p>
<ul>
<li><strong>q</strong> - a Quad</li>
<li>returns this</li>
</ul></div></div><div class="code"><div class="wrapper">  addQuad : <span class="hljs-function"><span class="hljs-params">(q)</span> -&gt;</span>

    <span class="hljs-keyword">if</span> <span class="hljs-property">@indexed</span>? == <span class="hljs-literal">true</span>
      <span class="hljs-keyword">for</span> idx <span class="hljs-keyword">in</span> [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>]
        p = <span class="hljs-property">@_findV</span>(q.vertices[idx])
        <span class="hljs-keyword">if</span> p == -<span class="hljs-number">1</span>
          <span class="hljs-property">@vertices</span>.push q.vertices[idx]
          ti = <span class="hljs-property">@vertices</span>.length
          ti -= <span class="hljs-number">1</span>
          q.vertices[idx]._idx = ti
          <span class="hljs-property">@indices</span>.push(ti)
        <span class="hljs-keyword">else</span>
          <span class="hljs-property">@indices</span>.push(p)

      <span class="hljs-keyword">for</span> idx <span class="hljs-keyword">in</span> [<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>]
        p = <span class="hljs-property">@_findV</span>(q.vertices[idx])
        <span class="hljs-keyword">if</span> p == -<span class="hljs-number">1</span>
          <span class="hljs-property">@vertices</span>.push q.vertices[idx]
          ti = <span class="hljs-property">@vertices</span>.length
          ti -= <span class="hljs-number">1</span>
          q.vertices[idx]._idx = ti
          <span class="hljs-property">@indices</span>.push ti
        <span class="hljs-keyword">else</span>
          <span class="hljs-property">@indices</span>.push(p)

    <span class="hljs-keyword">else</span>
      <span class="hljs-property">@vertices</span>.push q.vertices[i] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>]
      <span class="hljs-property">@vertices</span>.push q.vertices[i] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> [<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>]

    <span class="hljs-property">@faces</span>.push(<span class="hljs-keyword">new</span> Triangle(q.vertices[<span class="hljs-number">0</span>], q.vertices[<span class="hljs-number">1</span>], q.vertices[<span class="hljs-number">3</span>]))
    <span class="hljs-property">@faces</span>.push(<span class="hljs-keyword">new</span> Triangle(q.vertices[<span class="hljs-number">2</span>], q.vertices[<span class="hljs-number">3</span>], q.vertices[<span class="hljs-number">1</span>]))
    
    @</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>_findV - Find the position in the array for this vertex
to speed this up we use a temporary _idx attribute if it exists</p></div></div><div class="code"><div class="wrapper">  _findV : <span class="hljs-function"><span class="hljs-params">(vf)</span> -&gt;</span>
    <span class="hljs-keyword">return</span> vf._idx <span class="hljs-keyword">if</span> vf._idx?

    <span class="hljs-keyword">if</span> <span class="hljs-property">@vertices</span>.length &gt; <span class="hljs-number">0</span>
      <span class="hljs-keyword">for</span> idx <span class="hljs-keyword">in</span> [<span class="hljs-number">0.</span>.(<span class="hljs-property">@vertices</span>.length - <span class="hljs-number">1</span>)]
        <span class="hljs-keyword">if</span> <span class="hljs-property">@vertices</span>[idx] == vf
          <span class="hljs-keyword">return</span> idx
    
    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>
      
<span class="hljs-built_in">module</span>.exports =
  Geometry : Geometry 
  <span class="hljs-attribute">Vertex</span>: Vertex
  Triangle : Triangle
  Quad : Quad
  TriangleMesh : TriangleMesh 
  VertexSoup : VertexSoup</div></div></div></div></body></html>