<!DOCTYPE html><html lang="en"><head><title>math/curve</title></head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0"><meta name="groc-relative-root" content="../"><meta name="groc-document-path" content="math/curve"><meta name="groc-project-path" content="src/math/curve.coffee"><link rel="stylesheet" type="text/css" media="all" href="../assets/style.css"><script type="text/javascript" src="../assets/behavior.js"></script><body><div id="meta"><div class="file-path">src/math/curve.coffee</div></div><div id="document"><div class="segment"><div class="comments "><div class="wrapper"><pre><code>             .__   
_________  __|  |  
\____ \  \/  /  |  
|  |_&gt; &gt;    &lt;|  |__
|   __/__/\_ \____/
|__|        \/     js

                PXL.js
                Benjamin Blundell - ben@pxljs.com
                http://pxljs.com

This software is released under the MIT Licence. See LICENCE.txt for details</code></pre></div></div><div class="code"><div class="wrapper">{Vec2, Vec3, Vec4, Matrix4, PI } = <span class="hljs-built_in">require</span> <span class="hljs-string">'../math/math'</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h2 id="curve2">Curve2</h2>
<p>The basis for a series of two dimensional curves. These may or may not be normalised
This class also can be used to represent a straight line with gradient one, through
the origin - basically your classic straight line</p></div></div><div class="code"><div class="wrapper"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Curve2</span></span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p><strong>@constructor</strong></p></div></div><div class="code"><div class="wrapper">  constructor : <span class="hljs-function"><span class="hljs-params">()</span> -&gt;</span>
    @</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p><strong>pointOnCurve</strong> - Return the point on this curve given u (or x)</p>
<ul>
<li><strong>u</strong> - a Number - Required</li>
<li>returns a new Vec2</li>
</ul></div></div><div class="code"><div class="wrapper">  pointOnCurve : <span class="hljs-function"><span class="hljs-params">(u)</span> -&gt;</span>
    <span class="hljs-keyword">new</span> Vec2 u,u</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p><strong>y</strong> - Given x give us y</p>
<ul>
<li><strong>x</strong> - a Number - Required</li>
<li>returns a Number</li>
</ul></div></div><div class="code"><div class="wrapper">  y : <span class="hljs-function"><span class="hljs-params">(x)</span> -&gt;</span>
    x</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p><strong>stepForU</strong> - given U return the step distance </p>
<ul>
<li><strong>x</strong> - Step along the curve x o</li>
<li>returns a Number</li>
</ul></div></div><div class="code"><div class="wrapper">  stepForU : <span class="hljs-function"><span class="hljs-params">(x)</span> -&gt;</span>
    x
  </div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p><strong>xForStep</strong> - given d step along the curve give us x</p>
<ul>
<li><strong>d</strong> - a Number</li>
<li>returns a Number</li>
</ul></div></div><div class="code"><div class="wrapper">  xForStep : <span class="hljs-function"><span class="hljs-params">(d)</span> -&gt;</span>
    x</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p><strong>pointDistance</strong> </p>
<ul>
<li><strong>d</strong> - a Number</li>
<li>returns a new Vec2</li>
</ul></div></div><div class="code"><div class="wrapper">  pointDistance : <span class="hljs-function"><span class="hljs-params">(d)</span> -&gt;</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>sqrt(d^2 / 2) = a</p></div></div><div class="code"><div class="wrapper">    t = Math.sqrt(d*d/<span class="hljs-number">2.0</span>)
    <span class="hljs-keyword">new</span> Vec2 t,t
 </div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p><strong>tangentOnCurve</strong></p>
<ul>
<li><strong>x</strong> - a Number</li>
<li>returns a new Vec2</li>
</ul></div></div><div class="code"><div class="wrapper">  tangentOnCurve : <span class="hljs-function"><span class="hljs-params">(x)</span> -&gt;</span>
    <span class="hljs-keyword">new</span> Vec2 <span class="hljs-number">1</span>,<span class="hljs-number">1</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p><strong>tangentDistance</strong></p>
<ul>
<li><strong>d</strong> - a Number</li>
<li>returns a new Vec2</li>
</ul></div></div><div class="code"><div class="wrapper">  <span class="hljs-attribute">tangentDistance</span>: <span class="hljs-function"><span class="hljs-params">(d)</span> -&gt;</span>
    <span class="hljs-keyword">new</span> Vec2 <span class="hljs-number">1</span>,<span class="hljs-number">1</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h2 id="curve">Curve</h2>
<p>The basis for any parametric curve. We cache values for distance and u so we can
step along the curve using distance or normalized values
TODO - Rename this as CurveP - for parametric</p></div></div><div class="code"><div class="wrapper"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Curve</span></span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Our step size along the curve to generate points</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-property">@step_rez</span> = <span class="hljs-number">0.01</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Cache points for speed as oppose to memory
TODO - Might change to instance variables later</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-property">@cache_table</span> = <span class="hljs-literal">true</span> 
  <span class="hljs-property">@cache_size</span> = <span class="hljs-number">200</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p><strong>@constructor</strong></p></div></div><div class="code"><div class="wrapper">  constructor : <span class="hljs-function"><span class="hljs-params">()</span> -&gt;</span>

    <span class="hljs-property">@length</span> = <span class="hljs-number">0</span>

    <span class="hljs-keyword">if</span> Curve.cache_table</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>create a table of positions as a cache</p></div></div><div class="code"><div class="wrapper">      <span class="hljs-property">@_table</span> = []
      step = <span class="hljs-number">1</span> / Curve.cache_size
      <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> [<span class="hljs-number">0.</span>.Curve.cache_size-<span class="hljs-number">1</span>]
        tu = i * step
        <span class="hljs-property">@_table</span>.push { u : tu, d : <span class="hljs-property">@stepForU</span>(tu) }
      <span class="hljs-property">@length</span> = <span class="hljs-property">@_table</span>[ <span class="hljs-property">@_table</span>.length - <span class="hljs-number">1</span>][<span class="hljs-string">"d"</span>]

    <span class="hljs-keyword">else</span>
      <span class="hljs-property">@length</span> = <span class="hljs-property">@stepForU</span>(<span class="hljs-number">1.0</span>)

    @</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p><strong>pointOnCurve</strong> - Return the point on this curve given u (or x)</p>
<ul>
<li><strong>u</strong> - a Number - Required</li>
<li>returns a new Vec3</li>
</ul></div></div><div class="code"><div class="wrapper">  pointOnCurve : <span class="hljs-function"><span class="hljs-params">(u)</span> -&gt;</span>
    <span class="hljs-keyword">new</span> Vec3 <span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p><strong>stepForU</strong> - given U return the step distance </p>
<ul>
<li><strong>x</strong> - Step along the curve x o</li>
<li>returns a Number</li>
</ul></div></div><div class="code"><div class="wrapper">  stepForU : <span class="hljs-function"><span class="hljs-params">(u)</span> -&gt;</span>

    <span class="hljs-keyword">if</span> u == <span class="hljs-number">0</span>
      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>

    prev_dist = <span class="hljs-number">0</span>
    curr_dist = <span class="hljs-number">0</span>
    prev_u = <span class="hljs-number">0</span>
    curr_u = <span class="hljs-number">0</span>
    prev_point = <span class="hljs-property">@pointOnCurve</span>(<span class="hljs-number">0</span>)
    curr_point = prev_point

    <span class="hljs-keyword">while</span> curr_u &lt; u
      prev_dist = curr_dist
      prev_u = curr_u
      prev_point.copy curr_point

      curr_u += Curve.step_rez
      curr_point = <span class="hljs-property">@pointOnCurve</span> curr_u
      curr_dist += curr_point.dist prev_point
      
    du = (u - prev_u) / (curr_u - prev_u)

    du * (curr_dist - prev_dist) + prev_dist 

   </div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p><strong>uForStep</strong> - given a euclidean distance what is the step</p>
<ul>
<li><strong>d</strong> - a Number</li>
<li>returns a new Vec3</li>
</ul></div></div><div class="code"><div class="wrapper">  uForStep : <span class="hljs-function"><span class="hljs-params">(d)</span> -&gt;</span>

    <span class="hljs-keyword">if</span> d == <span class="hljs-number">0</span>
      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>

    prev_dist = <span class="hljs-number">0</span>
    curr_dist = <span class="hljs-number">0</span>
    prev_u = <span class="hljs-number">0</span>
    curr_u = <span class="hljs-number">0</span>
    prev_point = <span class="hljs-property">@pointOnCurve</span>(<span class="hljs-number">0</span>)
    curr_point = prev_point

    <span class="hljs-keyword">while</span> curr_dist &lt; d
      prev_dist = curr_dist
      prev_u = curr_u
      prev_point.copy curr_point

      curr_u += Curve.step_rez
      curr_point = <span class="hljs-property">@pointOnCurve</span> curr_u
      curr_dist += curr_point.dist prev_point


    dd = d - prev_dist
    <span class="hljs-keyword">if</span> (curr_dist - prev_dist) &gt; <span class="hljs-number">0</span>    
      dd = dd / (curr_dist - prev_dist)

    dd * (curr_u - prev_u) + prev_u </div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p><strong>pointDistance</strong></p>
<ul>
<li><strong>d</strong> - a Number - Required</li>
<li>returns a new Vec3</li>
</ul></div></div><div class="code"><div class="wrapper">  pointDistance : <span class="hljs-function"><span class="hljs-params">(d)</span> -&gt;</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If we have a cache table step through it and find u</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">if</span> d == <span class="hljs-number">0</span>
      <span class="hljs-keyword">return</span> <span class="hljs-property">@pointOnCurve</span> <span class="hljs-number">0</span>

    <span class="hljs-keyword">if</span> d &gt;= <span class="hljs-property">@length</span>
      <span class="hljs-keyword">return</span> <span class="hljs-property">@pointOnCurve</span> <span class="hljs-number">1.0</span>

    <span class="hljs-keyword">if</span> <span class="hljs-property">@_table</span>
      curr_dist = <span class="hljs-number">0</span>
      curr_u = <span class="hljs-number">0</span>
      prev_dist = <span class="hljs-number">0</span>
      prev_u = <span class="hljs-number">0</span>

      <span class="hljs-keyword">for</span> step <span class="hljs-keyword">in</span> <span class="hljs-property">@_table</span>
       
        prev_u = curr_u
        prev_dist = curr_dist

        curr_u = step.u
        curr_dist = step.d 

        <span class="hljs-keyword">if</span> step.d &gt;= d
          <span class="hljs-keyword">break</span>

      dd = d - prev_dist
      <span class="hljs-keyword">if</span> (curr_dist - prev_dist) &gt; <span class="hljs-number">0</span>    
        dd = dd / (curr_dist - prev_dist)

      <span class="hljs-property">@pointOnCurve</span>( dd * (curr_u - prev_u) + prev_u )

    <span class="hljs-keyword">else</span> 
      <span class="hljs-property">@pointOnCurve</span> <span class="hljs-property">@uForStep</span> d</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p><strong>tangentOnCurve</strong> - get a tangent from the normalised co-ordinate</p>
<ul>
<li><strong>u</strong> - a Number - Required</li>
<li>returns a new Vec3</li>
</ul></div></div><div class="code"><div class="wrapper">  tangentOnCurve : <span class="hljs-function"><span class="hljs-params">(u)</span> -&gt;</span>
    v0 = <span class="hljs-property">@pointOnCurve</span>(u) 
    v1 = <span class="hljs-property">@pointOnCurve</span>(u + Curve.step_rez / <span class="hljs-number">2</span>)
    
    <span class="hljs-keyword">if</span> u &gt;= <span class="hljs-number">1.0</span>
      v1 = v0
      v0 = v1 - Curve.step_rez / <span class="hljs-number">2</span>

    Vec3.sub(v1,v0).normalize()</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p><strong>tangentDistance </strong> - get a tangent from the distance along the curve</p>
<ul>
<li><strong>d</strong> - a Number</li>
<li>returns a new Vec3</li>
</ul></div></div><div class="code"><div class="wrapper">  tangentDistance : <span class="hljs-function"><span class="hljs-params">(d)</span> -&gt;</span>
    v0 = <span class="hljs-property">@pointDistance</span>(d) 
    v1 = <span class="hljs-property">@pointDistance</span>(d + Curve.step_rez / <span class="hljs-number">2</span>)
    
    <span class="hljs-keyword">if</span> d &gt;= <span class="hljs-property">@length</span>
      v1 = v0
      v0 = v1 - Curve.step_rez / <span class="hljs-number">2</span>

    Vec3.sub(v1,v0).normalize()</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h2 id="beziercubic3">BezierCubic3</h2>
<p>A Quadratic, bezier curve with four vectors determining the shape
A 3D curve as oppose to 2D</p></div></div><div class="code"><div class="wrapper"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BezierCubic3</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Curve</span></span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p><strong>@constructor</strong></p>
<ul>
<li><strong>v0</strong> - a Vec3 - Required</li>
<li><strong>v1</strong> - a Vec3 - Required</li>
<li><strong>v2</strong> - a Vec3 - Required</li>
<li><strong>v3</strong> - a Vec3 - Required</li>
</ul></div></div><div class="code"><div class="wrapper">  constructor : <span class="hljs-function"><span class="hljs-params">(<span class="hljs-property">@v0</span>,<span class="hljs-property">@v1</span>,<span class="hljs-property">@v2</span>,<span class="hljs-property">@v3</span>)</span> -&gt;</span>
    <span class="hljs-keyword">super</span>()

  _B1 : <span class="hljs-function"><span class="hljs-params">(t)</span> -&gt;</span>
    t*t*t
  
  _B2 : <span class="hljs-function"><span class="hljs-params">(t)</span> -&gt;</span>
    <span class="hljs-number">3</span>*t*t*(<span class="hljs-number">1</span>-t)
  
  _B3 : <span class="hljs-function"><span class="hljs-params">(t)</span> -&gt;</span>
    <span class="hljs-number">3</span>*t*(<span class="hljs-number">1</span>-t)*(<span class="hljs-number">1</span>-t)

  _B4 : <span class="hljs-function"><span class="hljs-params">(t)</span> -&gt;</span> 
    (<span class="hljs-number">1</span>-t)*(<span class="hljs-number">1</span>-t)*(<span class="hljs-number">1</span>-t)</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p><strong>pointOnCurve</strong> </p>
<ul>
<li><strong>u</strong> - a Number - Range 0 to 1 - Required</li>
<li>returns a new Vec3</li>
</ul></div></div><div class="code"><div class="wrapper">  <span class="hljs-attribute">pointOnCurve</span>: <span class="hljs-function"><span class="hljs-params">(u)</span> -&gt;</span>
    <span class="hljs-keyword">new</span> Vec3( v0.x*<span class="hljs-property">@_B1</span>(u) + v1.x*<span class="hljs-property">@_B2</span>(u) + v2.x*<span class="hljs-property">@_B3</span>(u) + v3.x*<span class="hljs-property">@_B4</span>(u),
      v0.y*<span class="hljs-property">@_B1</span>(u) + v1.y*<span class="hljs-property">@_B2</span>(u) + v2.y*<span class="hljs-property">@_B3</span>(u) + v3.y*<span class="hljs-property">@_B4</span>(u),
      v0.z*<span class="hljs-property">@_B1</span>(u) + v1.z*<span class="hljs-property">@_B2</span>(u) + v2.z*<span class="hljs-property">@_B3</span>(u) + v3.z*<span class="hljs-property">@_B4</span>(u))
  </div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p><span class='doc-section-header'> f - The Focus as a Vec2, a - parameter of the line equation (or 0 if x directrix), b - parameter of the line equation (or 0 if y directrix), and c - parameter of the line equation</span></p>
<p>TODO This formula actually works IF you remmeber there are two answers
It DOESNT work for lines that are parallel to the x or y axis
We need to revert to the directrix equation for that - this happens
if either a or b is 0
Takes the line in the form ax + by + c = 0
This is nothing to do with the song &quot;Parabola&quot; by the band Tool; at least
I don&#39;t think it is :S</p></div></div><div class="code"><div class="wrapper"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parabola</span> </span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p><strong>constructor</strong></p>
<ul>
<li><strong>f</strong> - a Vec2 - Required</li>
<li><strong>a</strong> - a Number - Required</li>
<li><strong>b</strong> - a Number - Required</li>
<li><strong>c</strong> - a Number - Required</li>
</ul></div></div><div class="code"><div class="wrapper">  constructor : <span class="hljs-function"><span class="hljs-params">(<span class="hljs-property">@f</span>, <span class="hljs-property">@a</span>, <span class="hljs-property">@b</span>, <span class="hljs-property">@c</span>)</span> -&gt;</span>
    @</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p><strong>sample</strong></p>
<ul>
<li><strong>x</strong> - a Number - Required</li>
<li>returns an Array of Number - Length 2</li>
</ul></div></div><div class="code"><div class="wrapper">  sample : <span class="hljs-function"><span class="hljs-params">(x)</span> -&gt;</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Three ways to sample - arbitrary line, x axis or y axis</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">if</span> <span class="hljs-property">@a</span> == <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> <span class="hljs-property">@b</span> != <span class="hljs-number">0</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>x axis aligned
(x-h)^2 = 4p(y-k)</p></div></div><div class="code"><div class="wrapper">      h = <span class="hljs-property">@f</span>.x
      k = (<span class="hljs-property">@f</span>.y + <span class="hljs-property">@c</span>) / <span class="hljs-number">2</span>
      p = <span class="hljs-property">@f</span>.y - k

      a = <span class="hljs-number">1</span>/(<span class="hljs-number">4</span>*p)
      b = -h/(<span class="hljs-number">2</span>*p)
      c = (h*h)/(<span class="hljs-number">4</span>*p) + k
      y = a*x*x+b*x+c
      <span class="hljs-keyword">return</span> [y,y]

    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-property">@b</span> == <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> <span class="hljs-property">@a</span> != <span class="hljs-number">0</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>y axis aligned - use the quadratic formula as we will have two answers</p></div></div><div class="code"><div class="wrapper">      
      h = (<span class="hljs-property">@f</span>.x + <span class="hljs-property">@c</span>) / <span class="hljs-number">2</span>
      k = <span class="hljs-property">@f</span>.y
      p = <span class="hljs-property">@f</span>.x - h

      y0 = Math.sqrt(<span class="hljs-number">4</span>*p*(x-h)) + k
      y1 = k - Math.sqrt(<span class="hljs-number">4</span>*p*(x-h))
        
      <span class="hljs-keyword">return</span> [y0,y1]
   
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-property">@a</span> != <span class="hljs-number">0</span>  <span class="hljs-keyword">and</span> <span class="hljs-property">@b</span> != <span class="hljs-number">0</span>
      as = <span class="hljs-property">@a</span> * <span class="hljs-property">@a</span>
      bs = <span class="hljs-property">@b</span> * <span class="hljs-property">@b</span>
      cs = <span class="hljs-property">@c</span> * <span class="hljs-property">@c</span>
      u = <span class="hljs-property">@f</span>.x
      us = u * u
      v = <span class="hljs-property">@f</span>.y
      vs = v * v
      xs = x * x
      t0 = (-<span class="hljs-number">2</span>*as*v-<span class="hljs-number">2</span>*<span class="hljs-property">@a</span>*<span class="hljs-property">@b</span>*x-<span class="hljs-number">2</span>*bs*v-<span class="hljs-number">2</span>*<span class="hljs-property">@b</span>*<span class="hljs-property">@c</span>)

      t1 = Math.sqrt((t0*t0)-<span class="hljs-number">4</span>*as*(as*us-<span class="hljs-number">2</span>*as*u*x+as*vs-<span class="hljs-number">2</span>*<span class="hljs-property">@a</span>*<span class="hljs-property">@c</span>*x+bs*us-<span class="hljs-number">2</span>*bs*u*x+bs*vs+bs*xs-cs))
      t2 = <span class="hljs-number">2</span>*as*v+<span class="hljs-number">2</span>*<span class="hljs-property">@a</span>*<span class="hljs-property">@b</span>*x+<span class="hljs-number">2</span>*bs*v+<span class="hljs-number">2</span>*<span class="hljs-property">@b</span>*<span class="hljs-property">@c</span>
      t3 = <span class="hljs-number">2</span>*as

      [ (-t1 + t2) / t3, (t1 + t2) / t3 ]
    <span class="hljs-keyword">else</span>
      PXLError(<span class="hljs-string">"Malformed "</span>)
      <span class="hljs-keyword">return</span> [<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p><strong>lineCrossing</strong> - figure out where a line crosses this parabola given the equation in the form ax + by + c = 0</p>
<ul>
<li><strong>e</strong> - a Number - Required</li>
<li><strong>f</strong> - a Number - Required</li>
<li><strong>g</strong> - a Number - Required</li>
</ul></div></div><div class="code"><div class="wrapper">  lineCrossing : <span class="hljs-function"><span class="hljs-params">(e,f,g)</span> -&gt;</span>

    <span class="hljs-comment">#[e,f,g] = line.equation()</span>
    </div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>TODO - line crossing for edges that are parallel to a major axis!</p></div></div><div class="code"><div class="wrapper">    a = <span class="hljs-property">@a</span>
    b = <span class="hljs-property">@b</span>
    c = <span class="hljs-property">@c</span>
    as = <span class="hljs-property">@a</span> * <span class="hljs-property">@a</span> 
    bs = <span class="hljs-property">@b</span> * <span class="hljs-property">@b</span>
    cs = <span class="hljs-property">@c</span> * <span class="hljs-property">@c</span>
    fs = f * f
    es = e * e
    gs = g * g
    h = <span class="hljs-property">@f</span>.x
    k = <span class="hljs-property">@f</span>.y
    hs = h * h
    ks = k * k

    <span class="hljs-built_in">console</span>.log a,b,c,f,e,g,h,k

    t0 = (<span class="hljs-number">2</span>*as*e*f*k+<span class="hljs-number">2</span>*as*e*g-<span class="hljs-number">2</span>*as*fs*h+<span class="hljs-number">2</span>*a*b*f*g-<span class="hljs-number">2</span>*a*c*fs+<span class="hljs-number">2</span>*bs*e*f*k-<span class="hljs-number">2</span>*bs*fs*h+<span class="hljs-number">2</span>*b*c*e*f)
    <span class="hljs-built_in">console</span>.log <span class="hljs-string">"t0"</span>,t0
    t1 = <span class="hljs-number">4</span>*(as*es+<span class="hljs-number">2</span>*a*b*e*f+bs*fs)*(as*fs*hs+as*fs*ks+<span class="hljs-number">2</span>*as*f*g*k+as*gs+bs*fs*hs+bs*fs*ks+<span class="hljs-number">2</span>*bs*f*g*k+<span class="hljs-number">2</span>*b*c*f*g-cs*fs)
    <span class="hljs-built_in">console</span>.log <span class="hljs-string">"t1"</span>,t1
    t2 = <span class="hljs-number">2</span>*as*e*f*k-<span class="hljs-number">2</span>*as*e*g+<span class="hljs-number">2</span>*as*fs*h-<span class="hljs-number">2</span>*a*b*f*g+<span class="hljs-number">2</span>*a*c*fs-<span class="hljs-number">2</span>*bs*e*f*k+<span class="hljs-number">2</span>*bs*fs*h-<span class="hljs-number">2</span>*b*c*e*f
    <span class="hljs-built_in">console</span>.log <span class="hljs-string">"t2"</span>,t2
    t3 = <span class="hljs-number">2</span>*(as*es+<span class="hljs-number">2</span>*a*b*e*f+bs*fs)
    <span class="hljs-built_in">console</span>.log <span class="hljs-string">"t3"</span>,t3


    x0 = (-Math.sqrt(t0*t0-t1)-t2)/t3
    x1 = (Math.sqrt(t0*t0-t1)-t2)/t3
    
    [ <span class="hljs-keyword">new</span> Vec2(x0, (-e*x0-g)/f), <span class="hljs-keyword">new</span> Vec2(x1, (-e*x1-g)/f) ]</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h2 id="catmullpatch">CatmullPatch</h2></div></div></div><div class="segment"><div class="code"><div class="wrapper"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CatmullPatch</span> </span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>TODO - as we are are not keeping a count of the points, we cant really
alter the patch on the fly :( </p></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p><strong>@constructor</strong></p>
<ul>
<li><strong>points</strong> - an Array of Vec3 - Length 16 - Required
Assume points are given in column major order!</li>
</ul></div></div><div class="code"><div class="wrapper">  constructor : <span class="hljs-function"><span class="hljs-params">(points)</span> -&gt;</span>
    
    <span class="hljs-keyword">if</span> points.length != <span class="hljs-number">16</span>
      PXLError <span class="hljs-string">"Catmull Patch needs 16 points"</span>
      <span class="hljs-keyword">return</span>

    b = <span class="hljs-keyword">new</span> Matrix4([-<span class="hljs-number">0.5</span>,<span class="hljs-number">1</span>,-<span class="hljs-number">0.5</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1.5</span>,-<span class="hljs-number">2.5</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,-<span class="hljs-number">1.5</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0.5</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0.5</span>,-<span class="hljs-number">0.5</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>])</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Create the matrices we need for the output points</p></div></div><div class="code"><div class="wrapper">    t = []
    <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> points
      t.push p.x
    <span class="hljs-property">@px</span> = <span class="hljs-keyword">new</span> Matrix4(t)

    t = []
    <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> points
      t.push p.y
    <span class="hljs-property">@py</span> = <span class="hljs-keyword">new</span> Matrix4(t)

    t = []
    <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> points
      t.push p.z
    <span class="hljs-property">@pz</span> = <span class="hljs-keyword">new</span> Matrix4(t)

    bt = Matrix4.transpose(b)

    <span class="hljs-property">@px</span> = Matrix4.mult(b,<span class="hljs-property">@px</span>).mult(bt)
    <span class="hljs-property">@py</span> = Matrix4.mult(b,<span class="hljs-property">@py</span>).mult(bt)
    <span class="hljs-property">@pz</span> = Matrix4.mult(b,<span class="hljs-property">@pz</span>).mult(bt)</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p><strong>sample</strong> - Sample the patch with a vec2 (u,w) to gain the required point </p>
<ul>
<li><strong>v</strong> - a Vec2 - Required</li>
<li>returns a new Vec3</li>
</ul></div></div><div class="code"><div class="wrapper">  sample : <span class="hljs-function"><span class="hljs-params">(v)</span> -&gt;</span>
    u1 = v.x
    u2 = u1 * u1
    u3 = u2 * u1

    w1 = v.y
    w2 = w1 * w1
    w3 = w2 * w1
    
    u = <span class="hljs-keyword">new</span> Vec4(u3,u2,u1,<span class="hljs-number">1</span>)
    w = <span class="hljs-keyword">new</span> Vec4(w3,w2,w1,<span class="hljs-number">1</span>)

    um = Matrix4.multVec(<span class="hljs-property">@px</span>, w)
    x = u.x * um.x + u.y * um.y + u.z * um.z + u.w * um.w

    um = Matrix4.multVec(<span class="hljs-property">@py</span>, w)
    y = u.x * um.x + u.y * um.y + u.z * um.z + u.w * um.w

    um = Matrix4.multVec(<span class="hljs-property">@pz</span>, w)
    z = u.x * um.x + u.y * um.y + u.z * um.z + u.w * um.w

    <span class="hljs-keyword">new</span> Vec3(x,y,z)</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>TODO - eventually use the proper matrix <a href="http://www.cubic.org/docs/hermite.htm">http://www.cubic.org/docs/hermite.htm</a></p></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h2 id="cubichermitespline">CubicHermiteSpline</h2></div></div></div><div class="segment"><div class="code"><div class="wrapper"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CubicHermiteSpline</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Curve</span></span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p><strong>@constructor</strong></p>
<ul>
<li><strong>p0</strong> - a Vec2 or Vec3 - Required</li>
<li><strong>p1</strong> - a Vec2 or Vec3 - Required</li>
<li><strong>m0</strong> - a Vec2 or Vec3 - Required</li>
<li><strong>m1</strong> - a Vec2 or Vec3 - Required</li>
</ul></div></div><div class="code"><div class="wrapper">  constructor : <span class="hljs-function"><span class="hljs-params">(<span class="hljs-property">@p0</span>, <span class="hljs-property">@p1</span>, <span class="hljs-property">@m0</span>, <span class="hljs-property">@m1</span>)</span> -&gt;</span>
    <span class="hljs-keyword">super</span>()
    @</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p><strong>pointOnCurve</strong> - Return the point on this curve given u (or x)</p>
<ul>
<li><strong>u</strong> - a Number - Required</li>
<li>returns a new Vec2 or Vec3 </li>
</ul></div></div><div class="code"><div class="wrapper">  pointOnCurve : <span class="hljs-function"><span class="hljs-params">(u)</span> -&gt;</span>

    t3 = u*u*u 
    t2 = u*u

    c0 = <span class="hljs-property">@p0</span>.clone().multScalar(<span class="hljs-number">2</span> * t3 - <span class="hljs-number">3</span> * t2 + <span class="hljs-number">1</span>) 
    c1 = <span class="hljs-property">@m0</span>.clone().multScalar(t3 - <span class="hljs-number">2</span> * t2 + u)
    c2 = <span class="hljs-property">@p1</span>.clone().multScalar(-<span class="hljs-number">2</span> * t3 + <span class="hljs-number">3</span> * t2)
    c3 = <span class="hljs-property">@m1</span>.clone().multScalar(t3 - t2)

    c0.add(c1).add(c2).add(c3)</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h2 id="catmullromspline">CatmullRomSpline</h2>
<p>A collection of curves forming a Catmull-rom spline.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CatmullRomSpline</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Curve</span></span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>TODO - as we are are not keeping a count of the points, we cant really
alter the spline on the fly :(
<strong>@constructor</strong></p>
<ul>
<li><strong>points</strong> - an Array of Vec2 or Vec3 - Minimum Length 4 - Required</li>
</ul></div></div><div class="code"><div class="wrapper">  constructor : <span class="hljs-function"><span class="hljs-params">(points)</span> -&gt;</span>

    <span class="hljs-keyword">if</span> points.length &lt; <span class="hljs-number">4</span>
      PXLError <span class="hljs-string">"Catmull-Rom Spline needs at least 4 points"</span>
      <span class="hljs-keyword">return</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Build from a set of CubicHermiteSplines</p></div></div><div class="code"><div class="wrapper">    segments  = points.length - <span class="hljs-number">3</span>

    <span class="hljs-property">@splines</span> = []
 
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> [<span class="hljs-number">0.</span>.segments-<span class="hljs-number">1</span>]
      m0 = points[i+<span class="hljs-number">2</span>].clone().sub( points[i])
      m1 = points[i+<span class="hljs-number">3</span>].clone().sub( points[i+<span class="hljs-number">1</span>])

      <span class="hljs-property">@splines</span>.push <span class="hljs-keyword">new</span> CubicHermiteSpline points[i+<span class="hljs-number">1</span>], points[i+<span class="hljs-number">2</span>], m0, m1

    <span class="hljs-keyword">super</span>()
    @</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p><strong>pointOnCurve</strong> - Return the point on this curve given u (or x)</p>
<ul>
<li><strong>u</strong> - a Number - Range 0 to 1 - Required</li>
<li>returns a new Vec3</li>
</ul></div></div><div class="code"><div class="wrapper">  pointOnCurve : <span class="hljs-function"><span class="hljs-params">(u)</span> -&gt;</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Decide where in spline we are given the numbers we have</p></div></div><div class="code"><div class="wrapper">    segment  = Math.floor(u * <span class="hljs-property">@splines</span>.length)

    <span class="hljs-keyword">if</span> u &gt;= <span class="hljs-number">1</span>
      <span class="hljs-property">@splines</span>[<span class="hljs-property">@splines</span>.length-<span class="hljs-number">1</span>].pointOnCurve (<span class="hljs-number">1.0</span>)
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> u &lt;= <span class="hljs-number">0</span>
      <span class="hljs-property">@splines</span>[<span class="hljs-number">0</span>].pointOnCurve(<span class="hljs-number">0</span>)
    <span class="hljs-keyword">else</span>
      <span class="hljs-property">@splines</span>[segment].pointOnCurve ( (<span class="hljs-property">@splines</span>.length * u) - segment)</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h2 id="curveslide">CurveSlide</h2>
<p><a href="http://www.cs.cmu.edu/~fp/courses/graphics/asst5/cameraMovement.pdf">http://www.cs.cmu.edu/~fp/courses/graphics/asst5/cameraMovement.pdf</a>
essentially step along via a distance, passing in previous values
and setting new ones</p></div></div><div class="code"><div class="wrapper"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CurveSlide</span> </span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p><strong>@constructor</strong></p>
<ul>
<li><strong>curve</strong> - a Curve - Required</li>
<li><strong>normal</strong> - a Vec3 - Required</li>
</ul></div></div><div class="code"><div class="wrapper">  constructor : <span class="hljs-function"><span class="hljs-params">(<span class="hljs-property">@curve</span>, <span class="hljs-property">@normal</span>)</span> -&gt;</span>
    <span class="hljs-property">@reset</span> <span class="hljs-property">@normal</span>,<span class="hljs-number">0</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p><strong>reset</strong> - reset the slide starting from distance d, with a starting normal</p>
<ul>
<li><strong>normal</strong> - a Vec3 - Required</li>
<li><strong>d</strong> - a Number - Default 0</li>
<li>returns this</li>
</ul></div></div><div class="code"><div class="wrapper">  reset : <span class="hljs-function"><span class="hljs-params">(<span class="hljs-property">@normal</span>, d=<span class="hljs-number">0</span>)</span> -&gt;</span>
    <span class="hljs-property">@d</span> = d
    <span class="hljs-property">@pos</span> = <span class="hljs-property">@curve</span>.pointDistance <span class="hljs-property">@d</span>
    <span class="hljs-property">@tangent</span> = <span class="hljs-property">@curve</span>.tangentDistance <span class="hljs-property">@d</span>
    <span class="hljs-property">@bp</span> = Vec3.cross <span class="hljs-property">@normal</span>, <span class="hljs-property">@tangent</span>
    <span class="hljs-property">@np</span> = <span class="hljs-property">@normal</span>
    <span class="hljs-property">@binormal</span> = <span class="hljs-property">@bp</span>
    @</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p><strong>slide</strong> - slide along the curve from the starting point by d distance</p>
<ul>
<li><strong>dd</strong> - a Number - Required</li>
<li>returns this</li>
</ul></div></div><div class="code"><div class="wrapper">  slide : <span class="hljs-function"><span class="hljs-params">(dd)</span> -&gt;</span>
    <span class="hljs-property">@d</span> += dd
    <span class="hljs-keyword">if</span> <span class="hljs-property">@d</span> &gt; <span class="hljs-property">@curve</span>.length
      <span class="hljs-property">@reset</span> <span class="hljs-property">@normal</span>, <span class="hljs-number">0</span>

    <span class="hljs-property">@pos</span> = <span class="hljs-property">@curve</span>.pointDistance <span class="hljs-property">@d</span>
    <span class="hljs-property">@tangent</span> = <span class="hljs-property">@curve</span>.tangentDistance <span class="hljs-property">@d</span>

    <span class="hljs-property">@bp</span> = <span class="hljs-property">@binormal</span>
 
    <span class="hljs-property">@normal</span> = Vec3.cross <span class="hljs-property">@bp</span>, <span class="hljs-property">@tangent</span>
    <span class="hljs-property">@binormal</span> = Vec3.cross <span class="hljs-property">@tangent</span>, <span class="hljs-property">@normal</span>
    @</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h2 id="nurb">NURB</h2>
<p>NURB Class
TODO - Most of it - there is still a fair bit to go</p></div></div><div class="code"><div class="wrapper"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NURB</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Curve</span></span>
  constructor : <span class="hljs-function"><span class="hljs-params">()</span> -&gt;</span>
    @

<span class="hljs-built_in">module</span>.exports = 
  Curve2 : Curve2
  <span class="hljs-attribute">BezierCubic3</span>:  BezierCubic3
  CubicHermiteSpline : CubicHermiteSpline
  CatmullRomSpline : CatmullRomSpline
  Parabola : Parabola
  CatmullPatch : CatmullPatch
  CurveSlide : CurveSlide</div></div></div></div></body></html>