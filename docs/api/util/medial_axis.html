<!DOCTYPE html>

<html>
<head>
  <title>medial_axis.coffee</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="../docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
    <ul class="sections">
        
          <li id="title">
              <div class="annotation">
                  <h1>medial_axis.coffee</h1>
              </div>
          </li>
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              <h2 id="about">ABOUT</h2>

            </div>
            
            <div class="content"><div class='highlight'><pre>             .__   
_________  __|  |  
\____ \  \/  /  |  
|  |_&gt; &gt;    &lt;|  |__
|   __<span class="hljs-regexp">/__/</span>\_ \____/
|__|        \/     js

                    PXL.js
                    Benjamin Blundell - ben@pxljs.com
                    http:<span class="hljs-regexp">//</span>pxljs.com

This software <span class="hljs-keyword">is</span> released under the MIT Licence. See LICENCE.txt <span class="hljs-keyword">for</span> details</pre></div></div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <p>##</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
{Vec2,Edge2,Parabola} = <span class="hljs-built_in">require</span> <span class="hljs-string">'../math/math'</span>
{edge2Bisector} = <span class="hljs-built_in">require</span> <span class="hljs-string">'../math/math_functions'</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MedialComponent</span> </span></pre></div></div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <p>Start and end are Vec2 points and the @component is either an edge or a </p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  constructor : <span class="hljs-function"><span class="hljs-params">(@start, @end)</span> -&gt;</span>
    @

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MedialComponentEdge</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">MedialComponent</span></span>
  constructor : <span class="hljs-function"><span class="hljs-params">(@edge)</span> -&gt;</span>
    @</pre></div></div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <p>a value of 0 - 1 that samples between start and end </p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  sample : <span class="hljs-function"><span class="hljs-params">(dt)</span> -&gt;</span>
    dx = ((@end.x - @start.x) * dt) + @start.x
    @edge.sample(dx)


<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MedialComponentParabola</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">MedialComponent</span></span>
  constructor : <span class="hljs-function"><span class="hljs-params">(@parabola)</span> -&gt;</span>
    @

  sample : <span class="hljs-function"><span class="hljs-params">(dt)</span> -&gt;</span>
    dx = ((@end.x - @start.x) * dt) + @start.x
    dy = ((@end.y - @start.y) * dt) + @start.y</pre></div></div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <p>Basically find the nearest y value to DY - not sure that is totally correct though :S</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    [y0,y1] = @parabola.sample(dx)
    <span class="hljs-keyword">if</span> y1 != y0
      <span class="hljs-keyword">if</span> Math.abs(y0 - dy) &lt; Math.abs(y1-dy)
        <span class="hljs-keyword">return</span> y0
      <span class="hljs-keyword">else</span>
        <span class="hljs-keyword">return</span> y1
    y0

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MedialGraph</span></span>

  constructor : <span class="hljs-function">-&gt;</span>
    @components = []
    @right_handed = <span class="hljs-literal">true</span></pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <p>Compute the voronoi graph for two joined edges</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  voronoiEdgeEdge : <span class="hljs-function"><span class="hljs-params">(edge0, edge1)</span> -&gt;</span>
    bisector = edge2Bisector edge0, edge1</pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <p>As the bisector will only be for edges with angles less than 180, we can assume the shortest
edge is the one that will be crossed first
for now, we consider a</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    short_edge  = edge1
    long_edge = edge0

    <span class="hljs-keyword">if</span> edge0.length() &lt; edge1.length()
      short_edge = edge0
      long_edge = edge1

    [knot_point, influence_point] = @edgeLineInfluence bisector, short_edge, @right_handed

    parta = <span class="hljs-keyword">new</span> Edge2 bisector.start, knot_point

    @components.push <span class="hljs-keyword">new</span> MedialComponentEdge parta

    [a,b,c] = long_edge.equation()</pre></div></div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <p>TODO - how do we know which parabola result to choose?</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    parabola = <span class="hljs-keyword">new</span> Parabola(influence_point,a,b,c) 

    cp = @edgeParabolaInfluence(parabola,long_edge,@right_handed)

    parabola</pre></div></div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <p>Function that determines where a parabola leaves the area of influence of an edge.
Takes the line in the form ax + by + c = 0</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
  edgeParabolaInfluence : <span class="hljs-function"><span class="hljs-params">(parabola, edge, right)</span> -&gt;</span>

    [ea,eb,ec] = edge.equation()

    psa = eb
    psb = -ea
    psc = ea * edge.start.x + eb * edge.start.y + ec - eb * edge.start.x + ea * edge.start.y

    pea = eb
    peb = -ea
    pec = ea * edge.end.x + eb * edge.end.y + ec - eb * edge.end.x + ea * edge.end.y</pre></div></div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <p>two lines gives potentially 4 crossing points</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
    [s0,s1] = parabola.lineCrossing(psa,psb,psc)
    [e0,e1] = parabola.lineCrossing(pea,peb,pec)</pre></div></div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <p>console.log psa,psb,psc</p>

            </div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <p>console.log parabola.f, parabola.a, parabola.b, parabola.c</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
    <span class="hljs-built_in">console</span>.log s0,s1
    <span class="hljs-built_in">console</span>.log e0,e1

    spoints = [Vec2.normalize(s0), Vec2.normalize(s1)]
    epoints = [Vec2.normalize(e0), Vec2.normalize(e1)]

    tt = Vec2.normalize edge.start

    rp = []

    <span class="hljs-keyword">for</span> point <span class="hljs-keyword">in</span> spoints
      <span class="hljs-keyword">if</span> right
        <span class="hljs-keyword">if</span> tt.dot(point) &gt; <span class="hljs-number">0</span>
          rp.push([point, edge.start])
      
      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> tt.dot(point) &lt;= <span class="hljs-number">0</span>
          rp.push([point, edge.start])

    <span class="hljs-keyword">for</span> point <span class="hljs-keyword">in</span> epoints
      <span class="hljs-keyword">if</span> right
        <span class="hljs-keyword">if</span> tt.dot(point) &gt; <span class="hljs-number">0</span>
          rp.push([point, edge.end])
      
      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> tt.dot(point) &lt;= <span class="hljs-number">0</span>
          rp.push([point, edge.end])

    rp</pre></div></div>
            
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <p>Function that determines where a line equation leaves the area of influence of an edge
Takes the line in the form ax + by + c = 0</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
  edgeLineInfluence : <span class="hljs-function"><span class="hljs-params">(line,edge,right)</span> -&gt;</span></pre></div></div>
            
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <p>Get the equations of the lines perpendicular to edge, passing through the end points</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    [ea,eb,ec] = edge.equation()

    [a,b,c] = line.equation()

    psa = eb
    psb = -ea
    psc = ea * edge.start.x + eb * edge.start.y + ec - eb * edge.start.x + ea * edge.start.y

    pea = eb
    peb = -ea
    pec = ea * edge.end.x + eb * edge.end.y + ec - eb * edge.end.x + ea * edge.end.y</pre></div></div>
            
        </li>
        
        
        <li id="section-15">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              <p>find the intersection (hopefully they are not parallel lines :S )
We should have a determinate that is non-zero right?</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
    ys = (psa * c - psc * a) / (a * psb - psa * b)
    xs = (-b * ys - c) / a

    start_cross = <span class="hljs-keyword">new</span> Vec2(xs,ys)

    ye = (pea * c - pec * a) / (a * peb - pea * b)
    xe = (-b * ye - c) / a

    end_cross = <span class="hljs-keyword">new</span> Vec2(xe,ye)</pre></div></div>
            
        </li>
        
        
        <li id="section-16">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-16">&#182;</a>
              </div>
              <p>We consider only one side of the edge, depending on whether left or right is true</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
    ts = Vec2.normalize start_cross
    tt = Vec2.normalize edge.start

    ts.normalize()
    tt.normalize()

    <span class="hljs-keyword">if</span> right
      <span class="hljs-keyword">if</span> tt.dot(ts) &gt; <span class="hljs-number">0</span>
        <span class="hljs-keyword">return</span> [end_cross, edge.end]
      <span class="hljs-keyword">else</span>
        <span class="hljs-keyword">return</span> [start_cross, edge.start]
    
    <span class="hljs-keyword">if</span> tt.dot(ts) &lt;= <span class="hljs-number">0</span>
      <span class="hljs-keyword">return</span> [start_cross, edge.start]

    [end_cross, edge.end]</pre></div></div>
            
        </li>
        
        
        <li id="section-17">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-17">&#182;</a>
              </div>
              <h2 id="medialaxis2d">medialAxis2D</h2>
<p>Given a planar polygon (a list of 2D vertices), compute the the medial axis of the polygon
as a set of pairs of 2D points (edges)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-function">
<span class="hljs-title">medialAxis2D</span> = <span class="hljs-params">(polygon, top, left, bottom, right)</span> -&gt;</span></pre></div></div>
            
        </li>
        
        
        <li id="section-18">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-18">&#182;</a>
              </div>
              <p>create pairs / edges</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">if</span> polygon.length &lt; <span class="hljs-number">3</span>
    <span class="hljs-keyword">return</span> []

  edges = []
  <span class="hljs-keyword">for</span> idx <span class="hljs-keyword">in</span> [<span class="hljs-number">0.</span>.polygon.length<span class="hljs-number">-1</span>]
    <span class="hljs-keyword">if</span> idx + <span class="hljs-number">1</span> &lt; polygon.length
      edges.push [ polygon[idx], polygon[idx+<span class="hljs-number">1</span>] ]
    <span class="hljs-keyword">else</span>
      edges.push [ polygon[idx], polygon[<span class="hljs-number">0</span>] ]</pre></div></div>
            
        </li>
        
        
        <li id="section-19">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-19">&#182;</a>
              </div>
              <p>find the chains - As we are going clockwise winding, inside is to the right of the vector
which is a positive cross product with z ( I think!)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  chains = []
  current_chain = <span class="hljs-keyword">new</span> Array()

  <span class="hljs-keyword">for</span> idx <span class="hljs-keyword">in</span> [<span class="hljs-number">0.</span>.edges.length<span class="hljs-number">-1</span>]
    
    e0 = edges[idx]
    e1 = edges[idx+<span class="hljs-number">1</span>]
    
    <span class="hljs-keyword">if</span> idx + <span class="hljs-number">1</span> == edges.length
      e1 = edges[<span class="hljs-number">0</span>]

    v0 = Vec3.sub <span class="hljs-keyword">new</span> Vec3(e0[<span class="hljs-number">1</span>].x, e0[<span class="hljs-number">1</span>].y), <span class="hljs-keyword">new</span> Vec3(e0[<span class="hljs-number">0</span>].x, e0[<span class="hljs-number">0</span>].y)
    v1 = Vec3.sub <span class="hljs-keyword">new</span> Vec3(e1[<span class="hljs-number">1</span>].x, e1[<span class="hljs-number">1</span>].y), <span class="hljs-keyword">new</span> Vec3(e1[<span class="hljs-number">0</span>].x, e1[<span class="hljs-number">0</span>].y)

    cross = Vec3.cross v0, v1

    <span class="hljs-keyword">if</span> cross.z &gt; <span class="hljs-number">0</span></pre></div></div>
            
        </li>
        
        
        <li id="section-20">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-20">&#182;</a>
              </div>
              <p>Its a reflex angle, therefore a chain</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      
      <span class="hljs-keyword">if</span> current_chain.length == <span class="hljs-number">0</span>
        current_chain.push e0
      
      current_chain.push [e1[<span class="hljs-number">0</span>]] <span class="hljs-comment"># push the reflex vertex too if chain is greater than one edge</span>
      current_chain.push e1</pre></div></div>
            
        </li>
        
        
        <li id="section-21">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-21">&#182;</a>
              </div>
              <p>there is an edge case here whereby the last edge could be in a chain already 
but I suspect that is rare and can be handled anyway</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
    <span class="hljs-keyword">else</span></pre></div></div>
            
        </li>
        
        
        <li id="section-22">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-22">&#182;</a>
              </div>
              <p>not a chain</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> current_chain.length == <span class="hljs-number">0</span>
        current_chain.push e0

      chains.push current_chain
      current_chain = <span class="hljs-keyword">new</span> Array()

  voronoi = []
  wedges = []
  zaxis = <span class="hljs-keyword">new</span> Vec3(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)
  wedge_length =<span class="hljs-number">100.0</span></pre></div></div>
            
        </li>
        
        
        <li id="section-23">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-23">&#182;</a>
              </div>
              <p>we now have the chains so we must compute the voronoi diagram for each chain and combine</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">for</span> chain <span class="hljs-keyword">in</span> chains
    <span class="hljs-keyword">for</span> idx <span class="hljs-keyword">in</span> [<span class="hljs-number">0.</span>.chain.length<span class="hljs-number">-1</span>]</pre></div></div>
            
        </li>
        
        
        <li id="section-24">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-24">&#182;</a>
              </div>
              <p>Wedges denote the area of effect for computing our initial bisectors.
They are internal and are denoted by a point and a direction vector.
Each element has two lines that denote a wedge and we want to be inside them</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
      element = chain[idx]
      wedge = []</pre></div></div>
            
        </li>
        
        
        <li id="section-25">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-25">&#182;</a>
              </div>
              <p>compute the initial voronoi graph. The wedges for each element</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> element.length == <span class="hljs-number">2</span></pre></div></div>
            
        </li>
        
        
        <li id="section-26">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-26">&#182;</a>
              </div>
              <p>its an edge so two lines perpendicular</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        v0 = Vec3.sub <span class="hljs-keyword">new</span> Vec3(element[<span class="hljs-number">0</span>].x, element[<span class="hljs-number">0</span>].y), <span class="hljs-keyword">new</span> Vec3(element[<span class="hljs-number">1</span>].x, element[<span class="hljs-number">1</span>].y)
        cross = Vec3.cross v0, zaxis
        cross.normalize()

        wedge.push [<span class="hljs-keyword">new</span> Vec2(element[<span class="hljs-number">0</span>].x, element[<span class="hljs-number">0</span>].y), <span class="hljs-keyword">new</span> Vec2(element[<span class="hljs-number">0</span>].x - cross.x, element[<span class="hljs-number">0</span>].y - cross.y)]
        wedge.push [<span class="hljs-keyword">new</span> Vec2(element[<span class="hljs-number">1</span>].x, element[<span class="hljs-number">1</span>].y), <span class="hljs-keyword">new</span> Vec2(element[<span class="hljs-number">1</span>].x - cross.x, element[<span class="hljs-number">1</span>].y - cross.y)]

       
      <span class="hljs-keyword">else</span></pre></div></div>
            
        </li>
        
        
        <li id="section-27">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-27">&#182;</a>
              </div>
              <p>Its a reflex point so two lines perpendicular to the edges that join it</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        p = idx - <span class="hljs-number">1</span>
        <span class="hljs-keyword">if</span> idx == <span class="hljs-number">0</span>
          p = chain.length - <span class="hljs-number">1</span>

        n = idx + <span class="hljs-number">1</span>
        <span class="hljs-keyword">if</span> idx == chain.length - <span class="hljs-number">1</span>
          n = <span class="hljs-number">0</span>

        pe = chain[p]
        ne = chain[n]


        v0 = Vec3.sub <span class="hljs-keyword">new</span> Vec3(pe[<span class="hljs-number">0</span>].x, pe[<span class="hljs-number">0</span>].y), <span class="hljs-keyword">new</span> Vec3(pe[<span class="hljs-number">1</span>].x, pe[<span class="hljs-number">1</span>].y)
        cross = Vec3.cross v0, zaxis
        cross.normalize()
        wedge.push [<span class="hljs-keyword">new</span> Vec2(element[<span class="hljs-number">0</span>].x, element[<span class="hljs-number">0</span>].y),  <span class="hljs-keyword">new</span> Vec2(element[<span class="hljs-number">0</span>].x - cross.x, element[<span class="hljs-number">0</span>].y - cross.y)]

        v1 = Vec3.sub <span class="hljs-keyword">new</span> Vec3(ne[<span class="hljs-number">0</span>].x, ne[<span class="hljs-number">0</span>].y), <span class="hljs-keyword">new</span> Vec3(ne[<span class="hljs-number">1</span>].x, ne[<span class="hljs-number">1</span>].y)
        cross = Vec3.cross v1, zaxis
        cross.normalize()
        wedge.push [ <span class="hljs-keyword">new</span> Vec2(element[<span class="hljs-number">0</span>].x, element[<span class="hljs-number">0</span>].y),  <span class="hljs-keyword">new</span> Vec2(element[<span class="hljs-number">0</span>].x - cross.x, element[<span class="hljs-number">0</span>].y - cross.y)]
        
      wedges.push wedge

  <span class="hljs-built_in">console</span>.log wedges</pre></div></div>
            
        </li>
        
        
        <li id="section-28">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-28">&#182;</a>
              </div>
              <p>For now, compute the voronoi for two chains</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

  <span class="hljs-keyword">return</span> wedges

<span class="hljs-built_in">module</span>.exports = 
  MedialGraph : MedialGraph</pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>

