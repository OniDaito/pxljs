#ifdef MAT_PHONG
vec3 materialDiffuseColour = uMaterialDiffuseColour;
vec3 materialSpecularColour = uMaterialSpecularColour;
vec3 materialEmissiveColour = uMaterialEmissiveColour;
 
#ifdef VERTEX_TEXTURE
if(bitcheck(uUber0,10)){ materialDiffuseColour = texture2D(uSamplerDiffuse, vTexCoord).rgb;}
if(bitcheck(uUber0,11)){ materialSpecularColour = texture2D(uSamplerSpecular, vTexCoord).rgb;}
if(bitcheck(uUber0,12)){ materialEmissiveColour = texture2D(uSamplerEmissive, vTexCoord).rgb;}
#endif

vec3 specularLightWeighting = vec3(0.0, 0.0, 0.0);
vec3 diffuseLightWeighting = vec3(0.0, 0.0, 0.0);
vec3 materialAmbientColour = uMaterialAmbientColour * uAmbientLightingColour;
gl_FragColor = vec4(materialAmbientColour, 1.0);
vec3 eyeDirection = normalize(-vPosition.xyz);

#ifdef LIGHTING_POINT

for (int i=0; i < LIGHTING_NUM_POINT_LIGHTS; i++) {
  // TODO could potentially transform the lights in the vertex shader?
  // TODO - previously we added a break in here for lights - do we keep that?
  // TODO - attenuation factor
  vec3 lightDirection = normalize((uModelMatrix * vec4(uPointLightPos[i],1.0)).xyz - vPosition.xyz);
  vec3 reflectionDirection = reflect(-lightDirection, vTransformedNormal.xyz);
  float specularLightBrightness = pow(max(dot(reflectionDirection, eyeDirection), 0.0), uMaterialShininess);
  specularLightWeighting = specularLightWeighting + (uPointLightColour[i] * specularLightBrightness);
  float diffuseLightBrightness = max(dot(vTransformedNormal.xyz, lightDirection), 0.0);
  diffuseLightWeighting = diffuseLightWeighting + (uPointLightColour[i] * diffuseLightBrightness);
  gl_FragColor += vec4( materialDiffuseColour * diffuseLightWeighting 
   + materialSpecularColour * specularLightWeighting
   + materialEmissiveColour,
   0.0);
}
#endif

#ifdef LIGHTING_SPOT

// TODO - shadowmap scale might be removed to its own place for use in other materials

vec3 shadow_scale[LIGHTING_NUM_SPOT_LIGHTS];
for (int i=0; i < LIGHTING_NUM_SPOT_LIGHTS; i++) {
  shadow_scale[i] = vec3(1.0,1.0,1.0);
}

#ifdef SHADOWMAP
// Unflattened texture lookups for now sadly
if(bitcheck(uUber0,14)) {
  vec4 lightdepth = texture2D(uSamplerPointShadow[0],vShadowTexCoord[0].xy);
  if(lightdepth.x < gl_FragCoord.z ){
    shadow_scale[0] = vec3(0.0,0.0,0.0);
  }
  
  lightdepth = texture2D(uSamplerPointShadow[1],vShadowTexCoord[1].xy);
  if(lightdepth.x < gl_FragCoord.z ){
    shadow_scale[1] = vec3(0.0,0.0,0.0);
  }

  lightdepth = texture2D(uSamplerPointShadow[2],vShadowTexCoord[2].xy);
  if(lightdepth.x < gl_FragCoord.z ){
    shadow_scale[2] = vec3(0.0,0.0,0.0);
  }

  lightdepth = texture2D(uSamplerPointShadow[3],vShadowTexCoord[3].xy);
  if(lightdepth.x < gl_FragCoord.z ){
    shadow_scale[3] = vec3(0.0,0.0,0.0);
  }

  lightdepth = texture2D(uSamplerPointShadow[4],vShadowTexCoord[4].xy);
  if(lightdepth.x < gl_FragCoord.z ){
    shadow_scale[4] = vec3(0.0,0.0,0.0);
  }
}
#endif

for (int i=0; i < LIGHTING_NUM_SPOT_LIGHTS; i++) {
  vec3 lightDirection = normalize((uModelMatrix * vec4(uSpotLightPos[i],1.0)).xyz - vPosition.xyz);
  float spotFactor = dot ( -lightDirection, uSpotLightDir[i]);
  if (spotFactor >= cos(uSpotLightAngle[i])){
    spotFactor = pow(spotFactor, uSpotLightExp[i]);
  } else {
    spotFactor = 0.0;
  }
  vec3 reflectionDirection = reflect(-lightDirection, vTransformedNormal.xyz);
  float specularLightBrightness = pow(max(dot(reflectionDirection, eyeDirection), 0.0), uMaterialShininess);
  specularLightWeighting = specularLightWeighting + (uSpotLightColour[i] * specularLightBrightness);
  float diffuseLightBrightness = max(dot(vTransformedNormal.xyz, lightDirection), 0.0);
  diffuseLightWeighting = diffuseLightWeighting + (uSpotLightColour[i] * diffuseLightBrightness);
  specularLightWeighting *= spotFactor;
  diffuseLightWeighting *= spotFactor;
  vec3 final =  (materialDiffuseColour * diffuseLightWeighting + materialSpecularColour * specularLightWeighting + materialEmissiveColour) * shadow_scale[i];
  gl_FragColor += vec4(final,0.0);
}
#endif
#endif
